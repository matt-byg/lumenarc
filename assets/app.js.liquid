/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 812:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ PageAgeGate),
/* harmony export */   "G": () => (/* binding */ SiteAgeGate)
/* harmony export */ });

/*!
 * @pixelunion/age-gate v1.1.0
 * (c) 2023 Pixel Union
 */

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var scrollLock = __webpack_require__(265);
var isbot = __webpack_require__(458);
function getAge(birthdate) {
  var today = new Date();
  var age = today.getFullYear() - birthdate.getFullYear();
  var m = today.getMonth() - birthdate.getMonth();
  if (m < 0 || m === 0 && today.getDate() < birthdate.getDate()) {
    age--;
  }
  return age;
}
var SiteAgeGate = /*#__PURE__*/function () {
  function SiteAgeGate(el) {
    _classCallCheck(this, SiteAgeGate);
    this._el = el;
    this._ageGateForm = el.querySelector('[data-age-gate]');
    this._ageGateErrorEl = this._ageGateForm.querySelector('[data-age-gate-error]');
    this._requiredAge = this._ageGateForm.dataset.requiredAge;
    this._el.addEventListener('age-gate:open', this._open.bind(this));
    this._el.addEventListener('age-gate:close', this._close.bind(this));
    this._ageGateForm.addEventListener('submit', this._onFormSubmit.bind(this));
    if (isbot(navigator.userAgent)) {
      this._close();
    } else if (this._el.style.display === '') {
      this._open();
    }
  }
  _createClass(SiteAgeGate, [{
    key: "_open",
    value: function _open() {
      scrollLock.disablePageScroll();
      this._el.style.display = '';
    }
  }, {
    key: "_close",
    value: function _close() {
      scrollLock.enablePageScroll();
      this._el.style.display = 'none';
    }
  }, {
    key: "_onFormSubmit",
    value: function _onFormSubmit(event) {
      event.preventDefault();
      event.stopPropagation();
      var data = new FormData(event.target);
      var day = data.get('day');
      var month = data.get('month');
      var year = data.get('year');
      if (day === '' || month === '' || year === '') return;
      var age = getAge(new Date(year, month, day));
      if (age >= this._requiredAge) {
        this._close();
        sessionStorage.setItem('age-gate', age);
      } else {
        this._ageGateErrorEl.style.display = '';
      }
    }
  }]);
  return SiteAgeGate;
}();

var PageAgeGate = /*#__PURE__*/function () {
  function PageAgeGate() {
    _classCallCheck(this, PageAgeGate);
    this._ageGateEl = document.getElementById('age-gate-page');
  }
  _createClass(PageAgeGate, [{
    key: "onSectionLoad",
    value: function onSectionLoad() {
      var openEvent = new CustomEvent('age-gate:open');
      this._ageGateEl.dispatchEvent(openEvent);
    }
  }, {
    key: "onSectionSelect",
    value: function onSectionSelect() {
      var openEvent = new CustomEvent('age-gate:open');
      this._ageGateEl.dispatchEvent(openEvent);
    }
  }, {
    key: "onSectionDeselect",
    value: function onSectionDeselect() {
      var closeEvent = new CustomEvent('age-gate:close');
      this._ageGateEl.dispatchEvent(closeEvent);
    }
  }]);
  return PageAgeGate;
}();




/***/ }),

/***/ 569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eR": () => (/* binding */ transition)
/* harmony export */ });
/* unused harmony exports Animation, AnimationsManager, animation */

  /*!
   * @pixelunion/animations v0.1.0
   * (c) 2019 Pixel Union
   * Released under the UNLICENSED license.
  */

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Promisified version of window.requestAnimationFrame.
 * @returns {Promise} Promise will resolve when requestAnimationFrame callback is run.
 */
function raf() {
  return new Promise(function (resolve) {
    window.requestAnimationFrame(resolve);
  });
}
/**
 * Represents an HTML element with associate states
 */


var Animation =
/*#__PURE__*/
function () {
  /**
   * @param {Object} options
   * @param {HTMLElement}  options.el Target element
   * @param {String} [options.state=initial] Initial state. This is also the default state.
   * @param {String} [options.stateAttribute=data-revealer] Attribute name to update with state.
   * @param {String} [options.stateChangeAttribute=data-revealer-transition] Attribute name to
   * update with change of state.
   * @param {String} [options.endEvent=transitionend] Event to listen for at end of state change.
   * @param {Boolean} [options.hold=false] If true, changeAttribute will not be removed until the
   * next state change.
   * @param {Function} [options.onStart] Callback to execute immediate after
   * applying stateChangeAttribute.
   */
  function Animation(options) {
    _classCallCheck(this, Animation);

    this._el = options.el;
    this.cancelRunning = null;
    this._state = options.state || 'initial';
    this.initialState = this._state;
    this.stateAttribute = options.stateAttribute || 'data-animation-state';
    this.stateChangeAttribute = options.stateChangeAttribute || 'data-animation';
    this.endEvent = options.endEvent || 'transitionend';
    this.hold = !!options.hold;

    this.onStart = options.onStart || function () {
      /* do nothing */
    };

    this.activeEventHandler = null;
  }
  /**
   * Returns target element
   *
   * @return {HTMLElement} Target element
   */


  _createClass(Animation, [{
    key: "isState",

    /**
     * Check if a state is active
     * @param {String} state State to compare
     *
     * @return {Boolean}
     */
    value: function isState(state) {
      return state === this._state;
    }
    /**
     * Sequences a change to a new state.
     * @param {String} state Target state
     *
     * @param {Boolean} options.force Switch to final state immediately
     *
     * @param {Function} options.onStart Callback to execute immediately after
     * applying stateChangeAttribute for this state change only.
     *
     * @param {Boolean} [options.hold=false] If true, changeAttribute will not be removed until the
     * next state change.
     *
     * @return {Promise} Resolves when endEvent triggered
     */

  }, {
    key: "animateTo",
    value: function animateTo(state) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var from = this._el.dataset[this.stateAttribute] || this._state;
      var to = state || this.initialState;
      var force = options.force;
      var hold = 'hold' in options ? options.hold : this.hold;
      return new Promise(function (resolve) {
        if (_this.cancelRunning) {
          _this.cancelRunning();
        }

        if (from === to) {
          // Removing this here fixes some lingering attributes. But why?
          _this._el.removeAttribute(_this.stateChangeAttribute);

          resolve(from, null);
          return;
        }

        var running = true;

        _this.cancelRunning = function () {
          running = false;
          resolve(null, null);
        };

        _this._el.removeEventListener(_this.endEvent, _this.activeEventHandler);

        _this.activeEventHandler = null;

        if (force) {
          _this._el.setAttribute(_this.stateChangeAttribute, "".concat(from, "=>").concat(to));

          _this.onStart({
            el: _this._el,
            from: from,
            to: to
          });

          if (typeof options.onStart === 'function') {
            options.onStart({
              el: _this._el,
              from: from,
              to: to
            });
          }

          _this._el.setAttribute(_this.stateAttribute, to);

          _this._state = to;

          if (!hold) {
            _this._el.removeAttribute(_this.stateChangeAttribute);
          }

          resolve(to, null);
          return;
        }

        raf().then(function () {
          if (!running) throw new Error('cancelled');

          _this._el.setAttribute(_this.stateChangeAttribute, "".concat(from, "=>").concat(to));

          _this.onStart({
            el: _this._el,
            from: from,
            to: to
          });

          if (typeof options.onStart === 'function') {
            options.onStart({
              el: _this._el,
              from: from,
              to: to
            });
          }

          return raf();
        }).then(function () {
          if (!running) throw new Error('cancelled');

          _this._el.removeEventListener(_this.endEvent, _this.activeEventHandler);

          _this.activeEventHandler = function (e) {
            // Ignore any events bubbling up
            if (e.target !== _this._el || !running) return;

            _this._el.removeEventListener(_this.endEvent, _this.activeEventHandler);

            if (!hold) {
              _this._el.removeAttribute(_this.stateChangeAttribute);
            }

            resolve(to, e);
          };

          _this._el.addEventListener(_this.endEvent, _this.activeEventHandler);

          _this._el.setAttribute(_this.stateAttribute, to);

          _this._state = to;
        })["catch"](function (error) {
          // Only catch 'cancelled' errors.
          if (error.message !== 'cancelled') throw error;
        });
      });
    }
    /**
     * Remove any event listeners
     */

  }, {
    key: "unload",
    value: function unload() {
      this._el.removeEventListener(this.endEvent, this.activeEventHandler);

      this.activeEventHandler = null;
    }
  }, {
    key: "el",
    get: function get() {
      return this._el;
    }
    /**
     * Returns current state
     *
     * @return {String} Current state
     */

  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
  }]);

  return Animation;
}();

/**
 * Manage state changes for a set of elements
 */

var AnimationsManager =
/*#__PURE__*/
(/* unused pure expression or super */ null && (function () {
  function AnimationsManager() {
    _classCallCheck(this, AnimationsManager);

    this.animations = new Map();
  }
  /**
   * Add a new element and return an animation for that element. If element already has an associated animation, return that animation.
   * @param {Object} options
   * @param {HTMLElement}  options.el Target element
   * @param {String} [options.state=initial] Initial state. This is also the default state.
   * @param {String} [options.stateAttribute=data-revealer] Attribute name to update with state.
   * @param {String} [options.stateChangeAttribute=data-revealer-transition] Attribute name to update with change of state.
   * @param {String} [options.endEvent=transitionend] Event name to listen for at end of state change.
   * @param {Boolean} [options.hold=false] If true, changeAttribute will not be removed until the next state change.
   * @param {Function} [options.onStart] Callback to execute immediate after applying stateChangeAttribute.
   *
   * @return {Animation}
   */


  _createClass(AnimationsManager, [{
    key: "add",
    value: function add(options) {
      if (this.animations.has(options.el)) return this.animations.get(options.el);
      var animation = new Animation(options);
      this.animations.set(options.el, animation);
      return animation;
    }
    /**
     * Remove a single animation
     * @param {Animation} animation Animation to remove. Any event listeners will also be removed.
     */

  }, {
    key: "remove",
    value: function remove(animation) {
      this.animations["delete"](animation.el);
      animation.unload();
    }
    /**
     * Remove all animations, including all event listeners.
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      this.animations.forEach(function (animation) {
        return animation.unload();
      });
    }
  }]);

  return AnimationsManager;
}()));

function animation(options) {
  var setOptions = {
    endEvent: 'animationend',
    hold: true
  };
  return new Animation(_objectSpread2({
    options: options
  }, setOptions));
}

function transition(options) {
  return new Animation(options);
}




/***/ }),

/***/ 766:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = true;
var EventHandler = /** @class */ (function () {
    function EventHandler() {
        this.events = [];
    }
    EventHandler.prototype.register = function (el, event, listener) {
        if (!el || !event || !listener)
            return null;
        this.events.push({ el: el, event: event, listener: listener });
        el.addEventListener(event, listener);
        return { el: el, event: event, listener: listener };
    };
    EventHandler.prototype.unregister = function (_a) {
        var el = _a.el, event = _a.event, listener = _a.listener;
        if (!el || !event || !listener)
            return null;
        this.events = this.events.filter(function (e) { return el !== e.el
            || event !== e.event || listener !== e.listener; });
        el.removeEventListener(event, listener);
        return { el: el, event: event, listener: listener };
    };
    EventHandler.prototype.unregisterAll = function () {
        this.events.forEach(function (_a) {
            var el = _a.el, event = _a.event, listener = _a.listener;
            return el.removeEventListener(event, listener);
        });
        this.events = [];
    };
    return EventHandler;
}());
exports.Z = EventHandler;


/***/ }),

/***/ 598:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * @pixelunion/rimg-shopify v2.7.1
 * (c) 2023 Pixel Union
 */
/*!
 * @pixelunion/rimg v2.2.2
 * (c) 2022 Pixel Union
 */

/**
 * The default template render function. Turns a template string into an image
 * URL.
 *
 * @param {String} template
 * @param {Size} size
 * @returns {String}
 */
function defaultTemplateRender(template, size) {
  return template.replace('{size}', "".concat(size.width, "x").concat(size.height));
}
/**
 * @type Settings
 */


var defaults = {
  scale: 1,
  template: false,
  templateRender: defaultTemplateRender,
  max: {
    width: Infinity,
    height: Infinity
  },
  round: 32,
  placeholder: false,
  crop: null
};
/**
 * Get a data attribute value from an element, with a default fallback and
 * sanitization step.
 *
 * @param {Element} el
 *
 * @param {String} name
 *        The data attribute name.
 *
 * @param {Object} options
 *        An object holding fallback values if the data attribute does not
 *        exist. If this object doesn't have the property, we further fallback
 *        to our defaults.
 *
 * @param {Function} [sanitize]
 *        A function to sanitize the data attribute value with.
 *
 * @returns {String|*}
 */

function getData(el, name, options, sanitize) {
  var attr = "data-rimg-".concat(name);
  if (!el.hasAttribute(attr)) return options[name] || defaults[name];
  var value = el.getAttribute(attr);
  return sanitize ? sanitize(value) : value;
}
/**
 * Sanitize data attributes that represent a size (in the form of `10x10`).
 *
 * @param {String} value
 * @returns {Object} An object with `width` and `height` properties.
 */


function parseSize(value) {
  value = value.split('x');
  return {
    width: parseInt(value[0], 10),
    height: parseInt(value[1], 10)
  };
}
/**
 * Sanitize crop values to ensure they are valid, or null
 *
 * @param {String} value
 * @returns {Object} Shopify crop parameter ('top', 'center', 'bottom', 'left', 'right') or null, if an unsupported value is found
 */


function processCropValue(value) {
  switch (value) {
    case 'top':
    case 'center':
    case 'bottom':
    case 'left':
    case 'right':
      return value;

    default:
      return null;
  }
}
/**
 * Loads information about an element.
 *
 * Options can be set on the element itself using data attributes, or through
 * the `options` parameter. Data attributes take priority.
 *
 * @param {HTMLElement} el
 * @param {Settings} options
 * @returns {Item}
 */


function parseItem(el) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var isImage = el.hasAttribute('data-rimg-template');
  /**
   * @typedef {Settings} Item
   */

  return {
    el: el,
    // Type of element
    isImage: isImage,
    isBackgroundImage: isImage && el.tagName !== 'IMG',
    // Image scale
    scale: parseInt(getData(el, 'scale', options)),
    // Device density
    density: window.devicePixelRatio || 1,
    // Image template URL
    template: getData(el, 'template', options),
    templateRender: options.templateRender || defaults.templateRender,
    // Maximum image dimensions
    max: getData(el, 'max', options, parseSize),
    // Round image dimensions to the nearest multiple
    round: getData(el, 'round', options),
    // Placeholder image dimensions
    placeholder: getData(el, 'placeholder', options, parseSize),
    // Crop value; null if image is uncropped, otherwise equal to the Shopify crop parameter ('center', 'top', etc.)
    crop: getData(el, 'crop', options, processCropValue)
  };
}
/**
 * Round to the nearest multiple.
 *
 * This is so we don't tax the image server too much.
 *
 * @param {Number} size The size, in pixels.
 * @param {Number} [multiple] The multiple to round to the nearest.
 * @param {Number} [maxLimit] Maximum allowed value - value to return if rounded multiple is above this limit
 * @returns {Number}
 */


function roundSize(size) {
  var multiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
  var maxLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  return size === 0 ? multiple : Math.min(Math.ceil(size / multiple) * multiple, maxLimit);
}
/**
 * Get the size of an element.
 *
 * If it is too small, it's parent element is checked, and so on. This helps
 * avoid the situation where an element doesn't have a size yet or is positioned
 * out of the layout.
 *
 * @param {HTMLElement} el
 * @return {Object} size
 * @return {Number} size.width The width, in pixels.
 * @return {Number} size.height The height, in pixels.
 */


function getElementSize(el) {
  var size = {
    width: 0,
    height: 0
  };

  while (el) {
    size.width = el.offsetWidth;
    size.height = el.offsetHeight;
    if (size.width > 20 && size.height > 20) break;
    el = el.parentNode;
  }

  return size;
}
/**
 * Return the maximum supported density of the image, given the container.
 *
 * @param {Item} item
 * @param {Size} size
 */


function supportedDensity(item, size) {
  return Math.min(Math.min(Math.max(item.max.width / size.width, 1), item.density), Math.min(Math.max(item.max.height / size.height, 1), item.density)).toFixed(2);
}
/**
 * Trigger a custom event.
 *
 * Note: this approach is deprecated, but still required to support older
 * browsers such as IE 10.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events
 *
 * @param {HTMLElement} el
 *        The element to trigger the event on.
 *
 * @param {String} name
 *        The event name.
 *
 * @returns {Boolean}
 *          True if the event was canceled.
 */


function trigger(el, name) {
  var event = document.createEvent('Event');
  event.initEvent(name, true, true);
  return !el.dispatchEvent(event);
}
/**
 * Set the image URL on the element. Supports background images and `srcset`.
 *
 * @param {Item} item
 * @param {Size} size
 * @param {Boolean} isPlaceholder
 */


function setImage(item, size, isPlaceholder, onLoad) {
  var render = item.templateRender;
  var density = isPlaceholder ? 1 : supportedDensity(item, size);
  var round = isPlaceholder ? 1 : item.round; // Calculate the final display size, taking into account the image's
  // maximum dimensions.

  var targetWidth = size.width * density;
  var targetHeight = size.height * density;
  var displaySize;

  if (item.crop) {
    displaySize = {
      width: roundSize(targetWidth, round, item.max.width),
      height: roundSize(targetHeight, round, item.max.height)
    };
  } else {
    // Shopify serves images clamped by the requested dimensions (fitted to the smallest dimension).
    // To get the desired and expected pixel density we need to request cover dimensions (fitted to largest dimension).
    // This isn't a problem with cropped images which are served at the exact dimension requested.
    var containerAspectRatio = size.width / size.height;
    var imageAspectRatio = item.max.width / item.max.height;

    if (containerAspectRatio > imageAspectRatio) {
      // fit width
      displaySize = {
        width: roundSize(targetWidth, round, item.max.width),
        height: roundSize(targetWidth / imageAspectRatio, round, item.max.height)
      };
    } else {
      // fit height
      displaySize = {
        width: roundSize(targetHeight * imageAspectRatio, round, item.max.width),
        height: roundSize(targetHeight, round, item.max.height)
      };
    }
  }

  var url = render(item.template, displaySize); // On load callback

  var image = new Image();
  image.onload = onLoad;
  image.src = url; // Set image

  if (item.isBackgroundImage) {
    item.el.style.backgroundImage = "url('".concat(url, "')");
  } else {
    item.el.setAttribute('srcset', "".concat(url, " ").concat(density, "x"));
  }
}
/**
 * Load the image, set loaded status, and trigger the load event.
 *
 * @fires rimg:load
 * @fires rimg:error
 * @param {Item} item
 * @param {Size} size
 */


function loadFullImage(item, size) {
  var el = item.el;
  setImage(item, size, false, function (event) {
    if (event.type === 'load') {
      el.setAttribute('data-rimg', 'loaded');
    } else {
      el.setAttribute('data-rimg', 'error');
      trigger(el, 'rimg:error');
    }

    trigger(el, 'rimg:load');
  });
}
/**
 * Load in a responsive image.
 *
 * Sets the image's `srcset` attribute to the final image URLs, calculated based
 * on the actual size the image is being shown at.
 *
 * @fires rimg:loading
 *        The image URLs have been set and we are waiting for them to load.
 *
 * @fires rimg:loaded
 *        The final image has loaded.
 *
 * @fires rimg:error
 *        The final image failed loading.
 *
 * @param {Item} item
 */


function loadImage(item) {
  var el = item.el; // Already loaded?

  var status = el.getAttribute('data-rimg');
  if (status === 'loading' || status === 'loaded') return; // Is the SVG loaded?
  // In Firefox, el.complete always returns true [citation needed, may not be the case anymore, Jan/2022]
  // so we also check el.naturalWidth, which equals 0 until the image loads

  if (!item.isBackgroundImage) {
    if (el.naturalWidth === 0 || !el.complete) {
      // Wait for the load event, then call load image
      el.addEventListener('load', function cb() {
        el.removeEventListener('load', cb);
        loadImage(item);
      });
      return;
    }
  } // Trigger loading event, and stop if cancelled


  if (trigger(el, 'rimg:loading')) return; // Mark as loading

  el.setAttribute('data-rimg', 'loading'); // Get element size. This is used as the ideal display size.

  var size = getElementSize(item.el);
  size.width *= item.scale;
  size.height *= item.scale;

  if (item.placeholder) {
    // Load a placeholder image first, followed by the full image. Force the
    // element to keep its dimensions while it loads. If the image is smaller
    // than the element size, use the image's size. Density is taken into account
    // for HiDPI devices to avoid blurry images.
    if (!item.isBackgroundImage) {
      el.setAttribute('width', Math.min(Math.floor(item.max.width / item.density), size.width));
      el.setAttribute('height', Math.min(Math.floor(item.max.height / item.density), size.height));
    }

    setImage(item, item.placeholder, true, function () {
      return loadFullImage(item, size);
    });
  } else {
    loadFullImage(item, size);
  }
}
/**
 * Prepare an element to be displayed on the screen.
 *
 * Images have special logic applied to them to swap out the different sources.
 *
 * @fires rimg:enter
 *        The element is entering the viewport.
 *
 * @param {HTMLElement} el
 * @param {Settings} options
 */


function load(el, options) {
  if (!el) return;
  trigger(el, 'rimg:enter');
  var item = parseItem(el, options);

  if (item.isImage) {
    if (!item.isBackgroundImage) {
      el.setAttribute('data-rimg-template-svg', el.getAttribute('srcset'));
    }

    loadImage(item);
  }
}
/**
 * Reset an element's state so that its image can be recalculated.
 *
 * @fires rimg:update
 *        The element is being updated.
 *
 * @param {HTMLElement} el
 * @param {Settings} options
 */


function update(el, options) {
  if (!el) return;
  trigger(el, 'rimg:update');
  var item = parseItem(el, options);

  if (item.isImage) {
    if (!item.isBackgroundImage) {
      el.setAttribute('data-rimg', 'lazy');
      el.setAttribute('srcset', el.getAttribute('data-rimg-template-svg'));
    }

    loadImage(item);
  }
}
/**
 * Returns true if the element is within the viewport.
 * @param {HTMLElement} el
 * @returns {Boolean}
 */


function inViewport(el) {
  if (!el.offsetWidth || !el.offsetHeight || !el.getClientRects().length) {
    return false;
  }

  var root = document.documentElement;
  var width = Math.min(root.clientWidth, window.innerWidth);
  var height = Math.min(root.clientHeight, window.innerHeight);
  var rect = el.getBoundingClientRect();
  return rect.bottom >= 0 && rect.right >= 0 && rect.top <= height && rect.left <= width;
}
/**
 * @typedef {Object} Size
 * @property {Number} width
 * @property {Number} height
 */

/**
 * A function to turn a template string into a URL.
 *
 * @callback TemplateRenderer
 * @param {String} template
 * @param {Size} size
 * @returns {String}
 */

/**
 * @typedef {Object} Settings
 *
 * @property {String} [template]
 *           A template string used to generate URLs for an image. This allows us to
 *           dynamically load images with sizes to match the container's size.
 *
 * @property {TemplateRenderer} [templateRender]
 *           A function to turn a template string into a URL.
 *
 * @property {Size} [max]
 *           The maximum available size for the image. This ensures we don't
 *           try to load an image larger than is possible.
 * 
 * @property {Number} [scale]
 *           A number to scale the final image dimensions by. 
 *           Only applies to lazy-loaded images. Defaults to 1.
 *
 * @property {Number} [round]
 *           Round image dimensions to the nearest multiple. This is intended to
 *           tax the image server less by lowering the number of possible image
 *           sizes requested.
 *
 * @property {Size} [placeholder]
 *           The size of the lo-fi image to load before the full image.
 * 
 * @property {String} [crop]
 *           Crop value; null if image is uncropped, otherwise equal 
 *           to the Shopify crop parameter ('center', 'top', etc.).
 */

/**
 * Initialize the responsive image handler.
 *
 * @param {String|HTMLElement|NodeList} selector
 *        The CSS selector, element, or elements to track for lazy-loading.
 *
 * @param {Settings} options
 *
 * @returns {PublicApi}
 */


function rimg() {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="lazy"]';
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Intersections

  var io = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        io.unobserve(entry.target);
        load(entry.target, options);
      }
    });
  }, {
    // Watch the viewport, with 20% vertical margins
    rootMargin: '20% 0px'
  });
  /**
   * @typedef {Object} PublicApi
   */

  var api = {
    /**
     * Track a new selector, element, or nodelist for lazy-loading.
     * @type Function
     * @param {String|HTMLElement|NodeList} selector
     */
    track: function track() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="lazy"]';
      var els = querySelector(selector);

      for (var i = 0; i < els.length; i++) {
        // If an element is already in the viewport, load it right away. This
        // fixes a race-condition with dynamically added elements.
        if (inViewport(els[i])) {
          load(els[i], options);
        } else {
          io.observe(els[i]);
        }
      }
    },

    /**
     * Update element(s) that have already been loaded to force their images
     * to be recalculated.
     * @type Function
     * @param {String|HTMLElement|NodeList} selector
     */
    update: function update$1() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="loaded"]';
      var els = querySelector(selector);

      for (var i = 0; i < els.length; i++) {
        update(els[i], options);
      }
    },

    /**
     * Stop tracking element(s) for lazy-loading.
     * @type Function
     * @param {String|HTMLElement|NodeList} selector
     */
    untrack: function untrack() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg]';
      var els = querySelector(selector);

      for (var i = 0; i < els.length; i++) {
        io.unobserve(els[i]);
      }
    },

    /**
     * Manually load images.
     * @type Function
     * @param {String|HTMLElement|NodeList} selector
     */
    load: function load$1() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg]';
      var els = querySelector(selector);

      for (var i = 0; i < els.length; i++) {
        load(els[i], options);
      }
    },

    /**
     * Unload all event handlers and observers.
     * @type Function
     */
    unload: function unload() {
      io.disconnect();
    }
  }; // Add initial elements

  api.track(selector);
  return api;
}
/**
 * Finds a group of elements on the page.
 *
 * @param {String|HTMLElement|NodeList} selector
 * @returns {Object} An array-like object.
 */


function querySelector(selector) {
  if (typeof selector === 'string') {
    return document.querySelectorAll(selector);
  }

  if (selector instanceof HTMLElement) {
    return [selector];
  }

  if (selector instanceof NodeList) {
    return selector;
  }

  return [];
}

/**
 * Polyfill for Element.matches().
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
 */
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
    var matches = (this.document || this.ownerDocument).querySelectorAll(s),
        i = matches.length;

    while (--i >= 0 && matches.item(i) !== this) {}

    return i > -1;
  };
}

var state = {
  init: init,
  watch: watch,
  unwatch: unwatch,
  load: load$1
};

function init() {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[data-rimg="lazy"]';
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  state.selector = selector;
  state.instance = rimg(selector, options);
  state.loadedWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0); // Listen for Shopify theme editor events

  document.addEventListener('shopify:section:load', function (event) {
    return watch(event.target);
  });
  window.addEventListener('resize', function () {
    return _update();
  });
  document.addEventListener('shopify:section:unload', function (event) {
    return unwatch(event.target);
  }); // Listen for custom events to allow themes to hook into rimg

  document.addEventListener('theme:rimg:watch', function (event) {
    return watch(event.target);
  });
  document.addEventListener('theme:rimg:unwatch', function (event) {
    return unwatch(event.target);
  }); // Support custom events triggered through jQuery
  // See: https://github.com/jquery/jquery/issues/3347

  if (window.jQuery) {
    jQuery(document).on({
      'theme:rimg:watch': function themeRimgWatch(event) {
        return watch(event.target);
      },
      'theme:rimg:unwatch': function themeRimgUnwatch(event) {
        return unwatch(event.target);
      }
    });
  }
}
/**
 * Track an element, and its children.
 *
 * @param {HTMLElement} el
 */


function watch(el) {
  // Track element
  if (typeof el.matches === 'function' && el.matches(state.selector)) {
    state.instance.track(el);
  } // Track element's children


  state.instance.track(el.querySelectorAll(state.selector));
}
/**
 * Untrack an element, and its children
 *
 * @param {HTMLElement} el
 * @private
 */


function unwatch(el) {
  // Untrack element's children
  state.instance.untrack(el.querySelectorAll(state.selector)); // Untrack element

  if (typeof el.matches === 'function' && el.matches(state.selector)) {
    state.instance.untrack(el);
  }
}
/**
 * Manually load an image
 *
 * @param {HTMLElement} el
 */


function load$1(el) {
  // Load element
  if (typeof el.matches === 'function' && el.matches(state.selector)) {
    state.instance.load(el);
  } // Load element's children


  state.instance.load(el.querySelectorAll(state.selector));
}
/**
 * Update an element, and its children.
 *
 * @param {HTMLElement} el
 */


function _update() {
  var currentWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0); // Return if we're not 2x smaller, or larger than the existing loading size

  if (currentWidth / state.loadedWidth > 0.5 && currentWidth / state.loadedWidth < 2) {
    return;
  }

  state.loadedWidth = currentWidth;
  state.instance.update();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (state);


/***/ }),

/***/ 187:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

  /*!
   * @pixelunion/shopify-asyncview v2.0.5
   * (c) 2020 Pixel Union
  */

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var deferred = {};

var AsyncView = /*#__PURE__*/function () {
  function AsyncView() {
    _classCallCheck(this, AsyncView);
  }

  _createClass(AsyncView, null, [{
    key: "load",

    /**
     * Load the template given by the provided URL into the provided
     * view
     *
     * @param {string} url - The url to load
     * @param {object} query - An object containing additional query parameters of the URL
     * @param {string} query.view - A required query parameter indicating which view to load
     * @param {object} [options] - Config options
     * @param {string} [options.hash] - A hash of the current page content
     */
    value: function load(url) {
      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!('view' in query)) {
        return Promise.reject(new Error('\'view\' not found in \'query\' parameter'));
      }

      var querylessUrl = url.replace(/\?[^#]+/, '');
      var queryParamsString = new RegExp(/.+\?([^#]+)/).exec(url);
      var queryParams = query;

      if (queryParamsString && queryParamsString.length >= 2) {
        queryParamsString[1].split('&').forEach(function (param) {
          var _param$split = param.split('='),
              _param$split2 = _slicedToArray(_param$split, 2),
              key = _param$split2[0],
              value = _param$split2[1];

          queryParams[key] = value;
        });
      } // NOTE: We're adding an additional timestamp to the query.
      // This is to prevent certain browsers from returning cached
      // versions of the url we are requesting.
      // See this PR for more info: https://github.com/pixelunion/shopify-asyncview/pull/4


      var cachebustingParams = _objectSpread2({}, queryParams, {
        _: new Date().getTime()
      });

      var hashUrl = querylessUrl.replace(/([^#]+)(.*)/, function (match, address, hash) {
        return "".concat(address, "?").concat(Object.keys(queryParams).sort().map(function (key) {
          return "".concat(key, "=").concat(encodeURIComponent(queryParams[key]));
        }).join('&')).concat(hash);
      });
      var requestUrl = querylessUrl.replace(/([^#]+)(.*)/, function (match, address, hash) {
        return "".concat(address, "?").concat(Object.keys(cachebustingParams).sort().map(function (key) {
          return "".concat(key, "=").concat(encodeURIComponent(cachebustingParams[key]));
        }).join('&')).concat(hash);
      });
      var promise = new Promise(function (resolve, reject) {
        var data;

        if (hashUrl in deferred) {
          resolve(deferred[hashUrl]);
          return;
        }

        deferred[hashUrl] = promise;

        if (options.hash) {
          data = sessionStorage.getItem(hashUrl);

          if (data) {
            var deserialized = JSON.parse(data);

            if (options.hash === deserialized.options.hash) {
              delete deferred[hashUrl];
              resolve(deserialized);
              return;
            }
          }
        }

        var xhr = new XMLHttpRequest();
        xhr.open('GET', requestUrl, true);

        xhr.onload = function () {
          var el = xhr.response;
          var newOptions = {};
          var optionsEl = el.querySelector('[data-options]');

          if (optionsEl && optionsEl.innerHTML) {
            newOptions = JSON.parse(el.querySelector('[data-options]').innerHTML);
          }

          var htmlEls = el.querySelectorAll('[data-html]');
          var newHtml = {};

          if (htmlEls.length === 1 && htmlEls[0].getAttribute('data-html') === '') {
            newHtml = htmlEls[0].innerHTML;
          } else {
            for (var i = 0; i < htmlEls.length; i++) {
              newHtml[htmlEls[i].getAttribute('data-html')] = htmlEls[i].innerHTML;
            }
          }

          var dataEls = el.querySelectorAll('[data-data]');
          var newData = {};

          if (dataEls.length === 1 && dataEls[0].getAttribute('data-data') === '') {
            newData = JSON.parse(dataEls[0].innerHTML);
          } else {
            for (var _i = 0; _i < dataEls.length; _i++) {
              newData[dataEls[_i].getAttribute('data-data')] = JSON.parse(dataEls[_i].innerHTML);
            }
          }

          if (options.hash) {
            try {
              sessionStorage.setItem(hashUrl, JSON.stringify({
                options: newOptions,
                data: newData,
                html: newHtml
              }));
            } catch (error) {
              console.error(error);
            }
          }

          delete deferred[hashUrl];
          resolve({
            data: newData,
            html: newHtml
          });
        };

        xhr.onerror = function () {
          delete deferred[hashUrl];
          reject();
        };

        xhr.responseType = 'document';
        xhr.send();
      });
      return promise;
    }
  }]);

  return AsyncView;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AsyncView);


/***/ }),

/***/ 12:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/*!
 * @pixelunion/shopify-sections-manager v1.1.0
 * (c) 2021 Pixel Union
 */

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Allows a callback to be run once, when a target intersects the viewport.
 * @constructor
 * @param {Object} [options] options with which to construct the IntersectionObserver
 * @param {string} [options.rootMargin='30%'] A string which specifies a set of offsets to add to
 *                                          the root's bounding_box when calculating intersections.
 * @param {number} [options.threshold=0] Ratio of intersection required to trigger callback
 */
var LazyLoader = /*#__PURE__*/function () {
  function LazyLoader(options) {
    _classCallCheck(this, LazyLoader);

    var defaultOptions = {
      rootMargin: '30%',
      threshold: 0
    };
    this.callbacks = new WeakMap();
    this._observerCallback = this._observerCallback.bind(this);
    this.observer = new IntersectionObserver(this._observerCallback, _objectSpread2(_objectSpread2({}, defaultOptions), options));
  }
  /**
   * Add target and callback. Callback is only run once.
   * @add
   * @param {HTMLElement} target Target element
   * @param {function} callback Callback to run when target begins intersecting
   */


  _createClass(LazyLoader, [{
    key: "add",
    value: function add(target, callback) {
      this.callbacks.set(target, callback);
      this.observer.observe(target);
    }
    /**
     * Remove target. Associated callback is also removed.
     * @remove
     * @param {HTMLElement} target Target element
     */

  }, {
    key: "remove",
    value: function remove(target) {
      this.observer.unobserve(target);
      this.callbacks["delete"](target);
    }
    /**
     * Disconnects IntersectionObserver if active
     * @unload
     */

  }, {
    key: "unload",
    value: function unload() {
      this.observer.disconnect();
    }
    /**
     * Runs associated callbacks for each entry, then removes that entry and callback
     * @_observerCallback
     * @param {IntersectionObserverEntry[]} entries Entries to check
     * @param {InterserctionObserver} observer IntersectionObserver instance
     */

  }, {
    key: "_observerCallback",
    value: function _observerCallback(entries, observer) {
      var _this = this;

      entries.forEach(function (_ref) {
        var isIntersecting = _ref.isIntersecting,
            target = _ref.target;

        // do nothing unless target moved into state of intersection
        if (isIntersecting === true) {
          // make sure we stop observing before running the callback, so we don't
          // somehow run the callback twice if element intersects twice quickly
          observer.unobserve(target);

          var callback = _this.callbacks.get(target);

          if (typeof callback === 'function') {
            callback();
          }

          _this.callbacks["delete"](target);
        }
      });
    }
  }]);

  return LazyLoader;
}();

function triggerInstanceEvent(instance, eventName) {
  if (instance && instance[eventName]) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    instance[eventName].apply(instance, args);
  }
}

function loadData(el) {
  var dataEl = el.querySelector('[data-section-data]');
  if (!dataEl) return {}; // Load data from attribute, or innerHTML

  var data = dataEl.getAttribute('data-section-data') || dataEl.innerHTML;

  try {
    return JSON.parse(data);
  } catch (error) {
    console.warn("Sections: invalid section data found. ".concat(error.message));
    return {};
  }
}

var ShopifySectionsManager = /*#__PURE__*/function () {
  function ShopifySectionsManager() {
    _classCallCheck(this, ShopifySectionsManager);

    this.handlers = {};
    this.instances = {};
    this.options = {};
    this.lazyLoader = null;
    this._onSectionEvent = this._onSectionEvent.bind(this);
    document.addEventListener('shopify:section:load', this._onSectionEvent);
    document.addEventListener('shopify:section:unload', this._onSectionEvent);
    document.addEventListener('shopify:section:select', this._onSectionEvent);
    document.addEventListener('shopify:section:deselect', this._onSectionEvent);
    document.addEventListener('shopify:section:reorder', this._onSectionEvent);
    document.addEventListener('shopify:block:select', this._onSectionEvent);
    document.addEventListener('shopify:block:deselect', this._onSectionEvent);
  }
  /**
   * Stop listening for section events, and unbind all handlers.
   */


  _createClass(ShopifySectionsManager, [{
    key: "unbind",
    value: function unbind() {
      document.removeEventListener('shopify:section:load', this._onSectionEvent);
      document.removeEventListener('shopify:section:unload', this._onSectionEvent);
      document.removeEventListener('shopify:section:select', this._onSectionEvent);
      document.removeEventListener('shopify:section:deselect', this._onSectionEvent);
      document.removeEventListener('shopify:section:reorder', this._onSectionEvent);
      document.removeEventListener('shopify:block:select', this._onSectionEvent);
      document.removeEventListener('shopify:block:deselect', this._onSectionEvent); // Unload all instances

      for (var i = 0; i < this.instances.length; i++) {
        triggerInstanceEvent(this.instances[i], 'onSectionUnload');
      }

      this.handlers = {};
      this.options = {};
      this.lazyLoader.unload();
      this.lazyLoader = null;
      this.instances = {};
    }
    /**
     * Register a section handler.
     *
     * @param {string} type
     *        The section type to handle. The handler will be called for all
     *        sections with this type.
     *
     * @param {function} handler
     *        The handler function is passed information about a specific section
     *        instance. The handler is expected to return an object that will be
     *        associated with the section instance.
     *
     *        Section handlers are passed an object with the following parameters:
     *          {string} id
     *          An ID that maps to a specific section instance. Typically the
     *          section's filename for static sections, or a generated ID for
     *          dynamic sections.
     *
     *          {string} type
     *          The section type, as supplied when registered.
     *
     *          {Element} el
     *          The root DOM element for the section instance.
     *
     *          {Object} data
     *          Data loaded from the section script element. Defaults to an
     *          empty object.
     *
     *          {Function} postMessage
     *          A function that can be called to pass messages between sections.
     *          The function should be called with a message "name", and
     *          optionally some data.
     *
     * @param {object} options
     *
     * @param {boolean} options.lazy
     *     If true, sections will only be initialized after they intersect the viewport + 30% margin
     */

  }, {
    key: "register",
    value: function register(type, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (this.handlers[type]) {
        console.warn("Sections: section handler already exists of type '".concat(type, "'."));
      } // Store the section handler


      this.handlers[type] = handler; // Store options

      this.options[type] = options; // Init sections for this type

      this._initSections(type);
    }
    /**
     * Initialize sections already on the page.
     */

  }, {
    key: "_initSections",
    value: function _initSections(type) {
      var _this = this;

      // Fetch all existing sections of our type on the page
      var dataEls = document.querySelectorAll("[data-section-type=\"".concat(type, "\"]"));
      if (!dataEls) return; // Create an instance for each section

      var _loop = function _loop(i) {
        var dataEl = dataEls[i];
        var el = dataEl.parentNode; // Get instance ID

        var idEl = el.querySelector('[data-section-id]');

        if (!idEl) {
          console.warn("Sections: unable to find section id for '".concat(type, "'."), el);
          return {
            v: void 0
          };
        }

        var sectionId = idEl.getAttribute('data-section-id');

        if (!sectionId) {
          console.warn("Sections: unable to find section id for '".concat(type, "'."), el);
          return {
            v: void 0
          };
        }

        if (_this.options[type] && _this.options[type].lazy) {
          if (_this.lazyLoader === null) {
            _this.lazyLoader = new LazyLoader();
          }

          _this.lazyLoader.add(el, function () {
            return _this._createInstance(sectionId, el);
          });
        } else {
          _this._createInstance(sectionId, el);
        }
      };

      for (var i = 0; i < dataEls.length; i++) {
        var _ret = _loop(i);

        if (_typeof(_ret) === "object") return _ret.v;
      }
    }
  }, {
    key: "_onSectionEvent",
    value: function _onSectionEvent(event) {
      var el = event.target;
      var _event$detail = event.detail,
          sectionId = _event$detail.sectionId,
          blockId = _event$detail.blockId;
      var instance = this.instances[sectionId];

      switch (event.type) {
        case 'shopify:section:load':
          this._createInstance(sectionId, el);

          break;

        case 'shopify:section:unload':
          triggerInstanceEvent(instance, 'onSectionUnload', {
            el: el,
            id: sectionId
          });

          if (this.lazyLoader) {
            this.lazyLoader.remove(el);
          }

          delete this.instances[sectionId];
          break;

        case 'shopify:section:select':
          triggerInstanceEvent(instance, 'onSectionSelect', {
            el: el,
            id: sectionId
          });
          break;

        case 'shopify:section:deselect':
          triggerInstanceEvent(instance, 'onSectionDeselect', {
            el: el,
            id: sectionId
          });
          break;

        case 'shopify:section:reorder':
          triggerInstanceEvent(instance, 'onSectionReorder', {
            el: el,
            id: sectionId
          });
          break;

        case 'shopify:block:select':
          triggerInstanceEvent(instance, 'onSectionBlockSelect', {
            el: el,
            id: blockId
          });
          break;

        case 'shopify:block:deselect':
          triggerInstanceEvent(instance, 'onSectionBlockDeselect', {
            el: el,
            id: blockId
          });
          break;
      }
    }
  }, {
    key: "_postMessage",
    value: function _postMessage(name, data) {
      var _this2 = this;

      Object.keys(this.instances).forEach(function (id) {
        triggerInstanceEvent(_this2.instances[id], 'onSectionMessage', name, data);
      });
    }
  }, {
    key: "_createInstance",
    value: function _createInstance(id, el) {
      var typeEl = el.querySelector('[data-section-type]');
      if (!typeEl) return;
      var type = typeEl.getAttribute('data-section-type');
      if (!type) return;
      var handler = this.handlers[type];

      if (!handler) {
        console.warn("Sections: unable to find section handler for type '".concat(type, "'."));
        return;
      }

      var data = loadData(el);

      var postMessage = this._postMessage.bind(this);

      this.instances[id] = handler({
        id: id,
        type: type,
        el: el,
        data: data,
        postMessage: postMessage
      });
    }
  }]);

  return ShopifySectionsManager;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShopifySectionsManager);


/***/ }),

/***/ 923:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var LOCAL_STORAGE_KEY = 'pxu-shopify-surface-pick-up';
var loadingClass = 'surface-pick-up--loading';

var isNotExpired = function isNotExpired(timestamp) {
  return timestamp + 1000 * 60 * 60 >= Date.now();
};

var removeTrailingSlash = function removeTrailingSlash(s) {
  return s.replace(/(.*)\/$/, '$1');
}; // Haversine Distance
// The haversine formula is an equation giving great-circle distances between
// two points on a sphere from their longitudes and latitudes


function calculateDistance(latitude1, longitude1, latitude2, longitude2, unitSystem) {
  var dtor = Math.PI / 180;
  var radius = unitSystem === 'metric' ? 6378.14 : 3959;
  var rlat1 = latitude1 * dtor;
  var rlong1 = longitude1 * dtor;
  var rlat2 = latitude2 * dtor;
  var rlong2 = longitude2 * dtor;
  var dlon = rlong1 - rlong2;
  var dlat = rlat1 - rlat2;
  var a = Math.pow(Math.sin(dlat / 2), 2) + Math.cos(rlat1) * Math.cos(rlat2) * Math.pow(Math.sin(dlon / 2), 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return radius * c;
}

function getGeoLocation() {
  return _getGeoLocation.apply(this, arguments);
}

function _getGeoLocation() {
  _getGeoLocation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve, reject) {
              var options = {
                maximumAge: 3600000,
                // 1 hour
                timeout: 5000
              };

              if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function (_ref3) {
                  var coords = _ref3.coords;
                  return resolve(coords);
                }, reject, options);
              } else {
                reject();
              }
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getGeoLocation.apply(this, arguments);
}

function setLocation(_x) {
  return _setLocation.apply(this, arguments);
}

function _setLocation() {
  _setLocation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref) {
    var latitude, longitude, newData;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            latitude = _ref.latitude, longitude = _ref.longitude;
            newData = {
              latitude: latitude,
              longitude: longitude,
              timestamp: Date.now()
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(newData));
            return _context2.abrupt("return", fetch('/localization.json', {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                latitude: latitude,
                longitude: longitude
              })
            }).then(function () {
              return {
                latitude: latitude,
                longitude: longitude
              };
            }));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _setLocation.apply(this, arguments);
}

function getLocation() {
  return _getLocation.apply(this, arguments);
}

function _getLocation() {
  _getLocation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    var requestLocation,
        cachedLocation,
        _args3 = arguments;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            requestLocation = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;
            cachedLocation = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));

            if (!(cachedLocation && isNotExpired(cachedLocation.timestamp))) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt("return", cachedLocation);

          case 4:
            if (!requestLocation) {
              _context3.next = 6;
              break;
            }

            return _context3.abrupt("return", getGeoLocation().then(function (coords) {
              setLocation(coords); // We don't need to wait for this

              return coords;
            }));

          case 6:
            return _context3.abrupt("return", null);

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getLocation.apply(this, arguments);
}

var SurfacePickUp = /*#__PURE__*/function () {
  function SurfacePickUp(el, options) {
    _classCallCheck(this, SurfacePickUp);

    this.el = el;
    this.options = _objectSpread2({
      root_url: window.Theme && window.Theme.routes && window.Theme.routes.root_url || ''
    }, options);
    this.options.root_url = removeTrailingSlash(this.options.root_url);
    this.callbacks = [];
    this.onBtnPress = null;
    this.latestVariantId = null;
  }

  _createClass(SurfacePickUp, [{
    key: "load",
    value: function load(variantId) {
      var _this = this;

      // If no variant is available, empty element and quick-return
      if (!variantId) {
        this.el.innerHTML = '';
        return Promise.resolve(true);
      } // Because Shopify doesn't expose any `pick_up_enabled` data on the shop object, we
      // don't know if the variant might be, or is definitely not available for pick up.
      // Until we know the shop has > 0 pick up locations, we want to avoid prompting the
      // user for location data (it's annoying, and only makes sense to do if we use it).
      //
      // Instead, we have to make an initial request, check and see if any pick up locations
      // were returned, then ask for the users location, then make another request to get the
      // location-aware pick up locations.
      //
      // As far as I can tell the pick up aware locations differ only in sort order - which
      // we could do on the front end - but we're following this approach to ensure future
      // compatibility with any changes Shopify makes (maybe disabling options based on
      // user location, or whatever else).
      //
      // Shopify has indicated they will look into adding pick_up_enabled data to the shop
      // object, which which case this method can be greatly simplifed into 2 simple cases.


      this.latestVariantId = variantId;
      this.el.classList.add(loadingClass);
      return this._getData(variantId).then(function (data) {
        return _this._injectData(data);
      });
    }
  }, {
    key: "onModalRequest",
    value: function onModalRequest(callback) {
      if (this.callbacks.indexOf(callback) >= 0) return;
      this.callbacks.push(callback);
    }
  }, {
    key: "offModalRequest",
    value: function offModalRequest(callback) {
      this.callbacks.splice(this.callbacks.indexOf(callback));
    }
  }, {
    key: "unload",
    value: function unload() {
      this.callbacks = [];
      this.el.innerHTML = '';
    }
  }, {
    key: "_getData",
    value: function _getData(variantId) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var xhr = new XMLHttpRequest();
        var requestUrl = "".concat(_this2.options.root_url, "/variants/").concat(variantId, "/?section_id=surface-pick-up");
        xhr.open('GET', requestUrl, true);

        xhr.onload = function () {
          var el = xhr.response;
          var embed = el.querySelector('[data-html="surface-pick-up-embed"]');
          var itemsContainer = el.querySelector('[data-html="surface-pick-up-items"]');
          var items = itemsContainer.content.querySelectorAll('[data-surface-pick-up-item]');
          resolve({
            embed: embed,
            itemsContainer: itemsContainer,
            items: items,
            variantId: variantId
          });
        };

        xhr.onerror = function () {
          resolve({
            embed: {
              innerHTML: ''
            },
            itemsContainer: {
              innerHTML: ''
            },
            items: [],
            variantId: variantId
          });
        };

        xhr.responseType = 'document';
        xhr.send();
      });
    }
  }, {
    key: "_injectData",
    value: function _injectData(_ref2) {
      var _this3 = this;

      var embed = _ref2.embed,
          itemsContainer = _ref2.itemsContainer,
          items = _ref2.items,
          variantId = _ref2.variantId;

      if (variantId !== this.latestVariantId || items.length === 0) {
        this.el.innerHTML = '';
        this.el.classList.remove(loadingClass);
        return;
      }

      this.el.innerHTML = embed.innerHTML;
      this.el.classList.remove(loadingClass);
      var calculatedDistances = false;

      var calculateDistances = function calculateDistances() {
        if (calculatedDistances) return Promise.resolve();
        return getLocation(true).then(function (coords) {
          items.forEach(function (item) {
            var distanceEl = item.querySelector('[data-distance]');
            var distanceUnitEl = item.querySelector('[data-distance-unit]');
            var unitSystem = distanceUnitEl.dataset.distanceUnit;
            var itemLatitude = parseFloat(distanceEl.dataset.latitude);
            var itemLongitude = parseFloat(distanceEl.dataset.longitude);

            if (coords && isFinite(itemLatitude) && isFinite(itemLongitude)) {
              var distance = calculateDistance(coords.latitude, coords.longitude, itemLatitude, itemLongitude, unitSystem);
              distanceEl.innerHTML = distance.toFixed(1);
            } else {
              distanceEl.remove();
              distanceUnitEl.remove();
            }
          });
        })["catch"](function (e) {
          console.log(e);
          items.forEach(function (item) {
            var distanceEl = item.querySelector('[data-distance]');
            var distanceUnitEl = item.querySelector('[data-distance-unit]');
            distanceEl.remove();
            distanceUnitEl.remove();
          });
        })["finally"](function () {
          calculatedDistances = true;
        });
      };

      this.el.querySelector('[data-surface-pick-up-embed-modal-btn]').addEventListener('click', function () {
        calculateDistances().then(function () {
          return _this3.callbacks.forEach(function (callback) {
            return callback(itemsContainer.innerHTML);
          });
        });
      });
    }
  }]);

  return SurfacePickUp;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SurfacePickUp);


/***/ }),

/***/ 463:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ ComplementaryProducts)
/* harmony export */ });
/* harmony import */ var _pixelunion_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(766);
/* harmony import */ var _pixelunion_shopify_asyncview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
/* harmony import */ var _pixelunion_rimg_shopify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(598);



class ComplementaryProducts {
  constructor(options) {
    this.sectionEl = options.sectionEl;
    this.sectionId = options.sectionId;
    this.events = new _pixelunion_events__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z();
    this.productId = options.productId;
    this.includeIndicatorDots = options.includeIndicatorDots || false;
    this.recommendationsRoute = options.productRecommendationsRoute;
    this.limit = options.limit;
    const defaultArrowShape = {
      x0: 10,
      x1: 60,
      y1: 50,
      x2: 65,
      y2: 45,
      x3: 20
    };
    this.arrowShape = options.arrowShape || defaultArrowShape;
    this.recommendationsEl = this.sectionEl.querySelector('[data-complementary-products]');
    this.loadRecommendations();
  }

  loadRecommendations() {
    const url = `${this.recommendationsRoute}?section_id=${this.sectionId}&limit=${this.limit}&product_id=${this.productId}&intent=complementary`;
    _pixelunion_shopify_asyncview__WEBPACK_IMPORTED_MODULE_1__/* .default.load */ .Z.load(url, {
      view: ''
    }).then((_ref) => {
      let {
        html
      } = _ref;
      if (typeof html === 'object' && Object.keys(html).length === 0) return;

      if (html.trim().length === 0) {
        this.recommendationsEl.classList.add('complementary-products--no-recommendations');
        return;
      }

      this.recommendationsEl.innerHTML = html;

      if (!_pixelunion_rimg_shopify__WEBPACK_IMPORTED_MODULE_2__/* .default.instance */ .Z.instance) {
        _pixelunion_rimg_shopify__WEBPACK_IMPORTED_MODULE_2__/* .default.init */ .Z.init();
      }

      _pixelunion_rimg_shopify__WEBPACK_IMPORTED_MODULE_2__/* .default.watch */ .Z.watch(this.recommendationsEl);
      const slider = this.recommendationsEl.querySelector('[data-slider]');
      const slides = this.recommendationsEl.querySelectorAll('[data-slide]');

      if (slides.length > 1) {
        this.slider = $(slider).flickity({
          cellSelector: '[data-slide]',
          accessibility: false,
          adaptiveHeight: false,
          autoPlay: false,
          cellAlign: 'left',
          contain: true,
          imagesLoaded: true,
          pageDots: this.includeIndicatorDots,
          wrapAround: true,
          arrowShape: this.arrowShape
        });
        this.events.register(slider, 'rimg:load', () => {
          this.slider.resize();
        });
      }
    });
  }

  unload() {
    this.slider.destroy();
  }

}

/***/ }),

/***/ 880:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ PaymentTerms)
/* harmony export */ });
class PaymentTerms {
  constructor(el) {
    this._el = el;
    this._reference = this._el.querySelector('[data-payment-terms-reference] shopify-payment-terms');
    this._target = this._el.querySelector('[data-payment-terms-target]');
    if (!this._reference || !this._target) return;
    this._input = document.createElement('input');
    this._input.name = 'id';
    this._input.type = 'hidden';

    this._target.appendChild(this._input);

    this._target.appendChild(this._reference);

    this._target.style.display = null;
  }

  update(variantId) {
    if (!this._reference || !this._target) return;
    this._input.value = variantId;

    this._input.dispatchEvent(new Event('change', {
      bubbles: true
    }));
  }

}

/***/ }),

/***/ 680:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ RecipientForm)
/* harmony export */ });
/* harmony import */ var _pixelunion_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(766);
/* harmony import */ var _pixelunion_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(569);


class RecipientForm {
  constructor(el) {
    this.el = el;
    this.events = new _pixelunion_events__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z();
    this.recipientForm = this.el.querySelector('[data-recipient-form]');
    this.recipientFormInputs = this.el.querySelectorAll('[data-recipient-form-input]');
    this.recipientFormEmailInput = this.el.querySelector('[data-recipient-form-email-input]');
    this.disclosure = this.el.querySelector('[data-recipient-disclosure]');
    this.disclosureCheckbox = this.el.querySelector('[data-recipient-disclosure-checkbox]');
    this.checkmark = this.disclosure.querySelector('.checkmark');
    this.checkmarkCheck = this.disclosure.querySelector('.checkmark__check');
    this.fillAnimation = (0,_pixelunion_animations__WEBPACK_IMPORTED_MODULE_1__/* .transition */ .eR)({
      el: this.checkmark
    });
    this.checkAnimation = (0,_pixelunion_animations__WEBPACK_IMPORTED_MODULE_1__/* .transition */ .eR)({
      el: this.checkmarkCheck
    });
    this.events.register(this.recipientForm, 'keydown', event => this._onKeydown(event));
    this.events.register(this.disclosure, 'toggle', () => this._onToggle());
    this.events.register(this.disclosureCheckbox, 'change', () => this._onChange());
  }

  _onChange() {
    this.disclosure.open = this.disclosureCheckbox.checked;
  }

  _onKeydown(event) {
    // Prevent input form submission
    if (event.key === 'Enter' && event.target.matches('[data-recipient-form-input]')) {
      event.preventDefault();
    }
  }

  _onToggle() {
    if (this.disclosure.open) {
      this._showRecipientForm();
    } else {
      this._hideRecipientForm();
    }
  }

  _showRecipientForm() {
    if (this.checkmark && this.checkmarkCheck) {
      this.fillAnimation.animateTo('checked');
      this.checkAnimation.animateTo('checked');
    }

    this.disclosureCheckbox.checked = true;
    this.recipientFormEmailInput.required = true;
  }

  _hideRecipientForm() {
    if (this.checkmark && this.checkmarkCheck) {
      this.fillAnimation.animateTo('unchecked');
      this.checkAnimation.animateTo('unchecked');
    }

    this.disclosureCheckbox.checked = false;
    this.recipientFormEmailInput.required = false;

    this._resetRecipientForm();
  }

  _resetRecipientForm() {
    this.recipientFormInputs.forEach(el => {
      el.value = '';

      if (el.classList.contains('form-field-filled')) {
        el.classList.remove('form-field-filled');
      }
    });

    if (this.recipientForm.classList.contains('recipient-form--has-errors')) {
      this.recipientForm.classList.remove('recipient-form--has-errors');
    }
  }

}

/***/ }),

/***/ 581:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ ShippingCalculator)
});

;// CONCATENATED MODULE: ./node_modules/@shopify/theme-addresses/theme-addresses.js
/**
 * CountryProvinceSelector Constructor
 * @param {String} countryOptions the country options in html string
 */
function CountryProvinceSelector(countryOptions) {
  if (typeof countryOptions !== 'string') {
    throw new TypeError(countryOptions + ' is not a string.');
  }
  this.countryOptions = countryOptions;
}

/**
 * Builds the country and province selector with the given node element
 * @param {Node} countryNodeElement The <select> element for country
 * @param {Node} provinceNodeElement The <select> element for province
 * @param {Object} options Additional settings available
 * @param {CountryProvinceSelector~onCountryChange} options.onCountryChange callback after a country `change` event
 * @param {CountryProvinceSelector~onProvinceChange} options.onProvinceChange callback after a province `change` event
 */
CountryProvinceSelector.prototype.build = function (countryNodeElement, provinceNodeElement, options) {
  if (typeof countryNodeElement !== 'object') {
    throw new TypeError(countryNodeElement + ' is not a object.');
  }

  if (typeof provinceNodeElement !== 'object') {
    throw new TypeError(provinceNodeElement + ' is not a object.');
  }

  var defaultValue = countryNodeElement.getAttribute('data-default');
  options = options || {}

  countryNodeElement.innerHTML = this.countryOptions;
  countryNodeElement.value = defaultValue;

  if (defaultValue && getOption(countryNodeElement, defaultValue)) {
    var provinces = buildProvince(countryNodeElement, provinceNodeElement, defaultValue);
    options.onCountryChange && options.onCountryChange(provinces, provinceNodeElement, countryNodeElement);
  }

  // Listen for value change on the country select
  countryNodeElement.addEventListener('change', function (event) {
    var target = event.target;
    var selectedValue = target.value;
    
    var provinces = buildProvince(target, provinceNodeElement, selectedValue);
    options.onCountryChange && options.onCountryChange(provinces, provinceNodeElement, countryNodeElement);
  });

  options.onProvinceChange && provinceNodeElement.addEventListener('change', options.onProvinceChange);
}

/**
 * This callback is called after a user interacted with a country `<select>`
 * @callback CountryProvinceSelector~onCountryChange
 * @param {array} provinces the parsed provinces
 * @param {Node} provinceNodeElement province `<select>` element
 * @param {Node} countryNodeElement country `<select>` element
 */

 /**
 * This callback is called after a user interacted with a province `<select>`
 * @callback CountryProvinceSelector~onProvinceChange
 * @param {Event} event the province selector `change` event object
 */

/**
 * Returns the <option> with the specified value from the
 * given node element
 * A null is returned if no such <option> is found
 */
function getOption(nodeElement, value) {
  return nodeElement.querySelector('option[value="' + value +'"]')
}

/**
 * Builds the options for province selector
 */
function buildOptions (provinceNodeElement, provinces) {
  var defaultValue = provinceNodeElement.getAttribute('data-default');

  provinces.forEach(function (option) {
    var optionElement = document.createElement('option');
    optionElement.value = option[0];
    optionElement.textContent = option[1];

    provinceNodeElement.appendChild(optionElement);
  })

  if (defaultValue && getOption(provinceNodeElement, defaultValue)) {
    provinceNodeElement.value = defaultValue;
  }
}

/**
 * Builds the province selector
 */
function buildProvince (countryNodeElement, provinceNodeElement, selectedValue) {
  var selectedOption = getOption(countryNodeElement, selectedValue);
  var provinces = JSON.parse(selectedOption.getAttribute('data-provinces'));

  provinceNodeElement.options.length = 0;

  if (provinces.length) {
    buildOptions(provinceNodeElement, provinces)
  }

  return provinces;
}

// EXTERNAL MODULE: ./node_modules/@pixelunion/events/dist/EventHandler.js
var EventHandler = __webpack_require__(766);
;// CONCATENATED MODULE: ./source/scripts/helpers/ShippingCalculator.js


class ShippingCalculator {
  constructor(_ref) {
    let {
      el
    } = _ref;
    this.el = el;
    this.events = new EventHandler/* default */.Z();
    this.rates = this.el.querySelector('[data-shipping-rates]');
    this.message = this.el.querySelector('[data-shipping-message]');
    this.zip = this.el.querySelector('[data-shipping-calculator-zipcode]');
    this.submit = this.el.querySelector('[data-shipping-calculator-submit]');
    this.response = this.el.querySelector('[data-shipping-calculator-response]');
    this.countrySelect = this.el.querySelector('[data-shipping-calculator-country]');
    this.provinceSelect = this.el.querySelector('[data-shipping-calculator-province]');
    this.provinceContainer = this.el.querySelector('[data-shipping-calculator-province-container]');
    this.buildCalculator();
  }

  buildCalculator() {
    this.shippingCountryProvinceSelector = new CountryProvinceSelector(this.countrySelect.innerHTML);
    this.shippingCountryProvinceSelector.build(this.countrySelect, this.provinceSelect, {
      onCountryChange: provinces => {
        if (provinces.length) {
          this.provinceContainer.style.display = 'block';
        } else {
          this.provinceContainer.style.display = 'none';
        } // "Province", "State", "Region", etc. and "Postal Code", "ZIP Code", etc.
        // Even countries without provinces include a label.


        const {
          label,
          zip_label: zipLabel
        } = window.Countries[this.countrySelect.value];
        this.provinceContainer.querySelector('label[for="address_province"]').innerHTML = label;
        this.el.querySelector('label[for="address_zip"]').innerHTML = zipLabel;
      }
    });
    this.events.register(this.submit, 'click', e => {
      e.preventDefault();
      this.getRates();
    });
  }

  getRates() {
    const shippingAddress = {};
    shippingAddress.country = this.countrySelect ? this.countrySelect.value : '';
    shippingAddress.province = this.provinceSelect ? this.provinceSelect.value : '';
    shippingAddress.zip = this.zip ? this.zip.value : '';
    const queryString = Object.keys(shippingAddress).map(key => `${encodeURIComponent(`shipping_address[${key}]`)}=${encodeURIComponent(shippingAddress[key])}`).join('&');
    fetch(`${window.PXUTheme.routes.cart_url}/shipping_rates.json?${queryString}`).then(response => response.json()).then(data => this.displayRates(data));
  }

  displayRates(rates) {
    const propertyName = Object.keys(rates);
    this.clearRates();

    if (propertyName[0] === 'shipping_rates') {
      rates.shipping_rates.forEach(rate => {
        const rateLi = document.createElement('li');
        rateLi.innerHTML = `${rate.name}: ${this.formatPrice(rate.price)}`;
        this.rates.appendChild(rateLi);
      });

      if (rates.shipping_rates.length > 1) {
        this.message.innerHTML = `${window.PXUTheme.translation.additional_rates_part_1} ${rates.shipping_rates.length} ${window.PXUTheme.translation.additional_rates_part_2} ${this.zip.value}, ${this.provinceSelect.value}, ${this.countrySelect.value}, ${window.PXUTheme.translation.additional_rates_part_3} ${this.formatPrice(rates.shipping_rates[0].price)}`;
      } else {
        this.message.innerHTML = `${window.PXUTheme.translation.additional_rate} ${this.zip.value}, ${this.provinceSelect.value}, ${this.countrySelect.value}, ${window.PXUTheme.translation.additional_rate_at} ${this.formatPrice(rates.shipping_rates[0].price)}`;
      }

      this.response.classList.add('shipping-rates--display-rates');
    } else {
      this.message.innerHTML = `Error: ${propertyName[0]} ${rates[propertyName[0]]}`;
      this.response.classList.add('shipping-rates--display-error');
    }
  }

  clearRates() {
    this.response.classList.remove('shipping-rates--display-error', 'shipping-rates--display-rates');
    this.message.innerHTML = '';
    this.rates.innerHTML = '';
  }

  formatPrice(price) {
    let formattedPrice;

    if (window.PXUTheme.currency.display_format === 'money_with_currency_format') {
      formattedPrice = `<span class="money">${window.PXUTheme.currency.symbol}${price} ${window.PXUTheme.currency.iso_code}</span>`;
    } else {
      formattedPrice = `<span class="money">${window.PXUTheme.currency.symbol}${price}</span>`;
    }

    return formattedPrice;
  }

  unload() {
    this.events.unregisterAll();
  }

}

/***/ }),

/***/ 458:
/***/ ((module) => {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return fn;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet);
  privateSet.add(obj);
}

var list = [
	" daum[ /]",
	" deusu/",
	"(?:^| )site",
	"@[a-z]",
	"\\(at\\)[a-z]",
	"\\(github\\.com/",
	"\\[at\\][a-z]",
	"^12345",
	"^<",
	"^[\\w \\.\\-\\(\\)]+(/v?\\d+(\\.\\d+)?(\\.\\d{1,10})?)?$",
	"^[^ ]{50,}$",
	"^active",
	"^ad muncher",
	"^anglesharp/",
	"^anonymous",
	"^avsdevicesdk/",
	"^axios/",
	"^bidtellect/",
	"^biglotron",
	"^castro",
	"^clamav[ /]",
	"^cobweb/",
	"^coccoc",
	"^custom",
	"^ddg[_-]android",
	"^discourse",
	"^dispatch/\\d",
	"^downcast/",
	"^duckduckgo",
	"^facebook",
	"^fdm[ /]\\d",
	"^getright/",
	"^gozilla/",
	"^hatena",
	"^hobbit",
	"^hotzonu",
	"^hwcdn/",
	"^jeode/",
	"^jetty/",
	"^jigsaw",
	"^linkdex",
	"^lwp[-: ]",
	"^metauri",
	"^microsoft bits",
	"^movabletype",
	"^mozilla/\\d\\.\\d \\(compatible;?\\)$",
	"^mozilla/\\d\\.\\d \\w*$",
	"^navermailapp",
	"^netsurf",
	"^offline explorer",
	"^phantom",
	"^php",
	"^postman",
	"^postrank",
	"^python",
	"^read",
	"^reed",
	"^restsharp/",
	"^snapchat",
	"^space bison",
	"^svn",
	"^swcd ",
	"^taringa",
	"^test certificate info",
	"^thumbor/",
	"^tumblr/",
	"^user-agent:mozilla",
	"^valid",
	"^venus/fedoraplanet",
	"^w3c",
	"^webbandit/",
	"^webcopier",
	"^wget",
	"^whatsapp",
	"^xenu link sleuth",
	"^yahoo",
	"^yandex",
	"^zdm/\\d",
	"^zoom marketplace/",
	"^{{.*}}$",
	"adbeat\\.com",
	"appinsights",
	"archive",
	"ask jeeves/teoma",
	"bit\\.ly/",
	"bluecoat drtr",
	"bot",
	"browsex",
	"burpcollaborator",
	"capture",
	"catch",
	"check",
	"chrome-lighthouse",
	"chromeframe",
	"client",
	"cloud",
	"crawl",
	"dareboost",
	"datanyze",
	"dataprovider",
	"dejaclick",
	"dmbrowser",
	"download",
	"evc-batch/",
	"feed",
	"firephp",
	"freesafeip",
	"ghost",
	"gomezagent",
	"google",
	"headlesschrome/",
	"http",
	"httrack",
	"hubspot marketing grader",
	"hydra",
	"ibisbrowser",
	"images",
	"iplabel",
	"ips-agent",
	"java",
	"library",
	"mail\\.ru/",
	"manager",
	"monitor",
	"morningscore/",
	"neustar wpm",
	"news",
	"nutch",
	"offbyone",
	"optimize",
	"pageburst",
	"pagespeed",
	"perl",
	"pingdom",
	"powermarks",
	"preview",
	"proxy",
	"ptst[ /]\\d",
	"reader",
	"rexx;",
	"rigor",
	"rss",
	"scan",
	"scrape",
	"search",
	"serp ?reputation ?management",
	"server",
	"sogou",
	"sparkler/",
	"spider",
	"statuscake",
	"stumbleupon\\.com",
	"supercleaner",
	"synapse",
	"synthetic",
	"taginspector/",
	"torrent",
	"tracemyfile",
	"transcoder",
	"trendsmapresolver",
	"twingly recon",
	"url",
	"virtuoso",
	"wappalyzer",
	"webglance",
	"webkit2png",
	"websitemetadataretriever",
	"whatcms/",
	"wordpress",
	"zgrab"
];

/**
 * Mutate given list of patter strings
 * @param {string[]} list
 * @returns {string[]}
 */
function amend(list) {
  try {
    // Risk: Uses lookbehind assertion, avoid breakage in parsing by using RegExp constructor
    new RegExp('(?<! cu)bot').test('dangerbot'); // eslint-disable-line prefer-regex-literals
  } catch (error) {
    // Skip regex fixes
    return list;
  }
  [
  // Addresses: Cubot device
  ['bot', '(?<! cu)bot'],
  // Addresses: Android webview
  ['google', '(?<! (?:channel/|google/))google(?!(app|/google| pixel))'],
  // Addresses: libhttp browser
  ['http', '(?<!(?:lib))http'],
  // Addresses: java based browsers
  ['java', 'java(?!;)'],
  // Addresses: Yandex Search App
  ['search', '(?<! ya(?:yandex)?)search']].forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      search = _ref2[0],
      replace = _ref2[1];
    var index = list.lastIndexOf(search);
    if (~index) {
      list.splice(index, 1, replace);
    }
  });
  return list;
}

amend(list);
var flags = 'i';

/**
 * Test user agents for matching patterns
 */
var _list = /*#__PURE__*/new WeakMap();
var _pattern = /*#__PURE__*/new WeakMap();
var _update = /*#__PURE__*/new WeakSet();
var _index = /*#__PURE__*/new WeakSet();
var Isbot = /*#__PURE__*/function () {
  /**
   * @type {string[]}
   */

  /**
   * @type {RegExp}
   */

  function Isbot(patterns) {
    var _this = this;
    _classCallCheck(this, Isbot);
    _classPrivateMethodInitSpec(this, _index);
    _classPrivateMethodInitSpec(this, _update);
    _classPrivateFieldInitSpec(this, _list, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _pattern, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _list, patterns || list.slice());
    _classPrivateMethodGet(this, _update, _update2).call(this);
    var isbot = function isbot(ua) {
      return _this.test(ua);
    };
    return Object.defineProperties(isbot, Object.entries(Object.getOwnPropertyDescriptors(Isbot.prototype)).reduce(function (accumulator, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        prop = _ref2[0],
        descriptor = _ref2[1];
      if (typeof descriptor.value === 'function') {
        Object.assign(accumulator, _defineProperty({}, prop, {
          value: _this[prop].bind(_this)
        }));
      }
      if (typeof descriptor.get === 'function') {
        Object.assign(accumulator, _defineProperty({}, prop, {
          get: function get() {
            return _this[prop];
          }
        }));
      }
      return accumulator;
    }, {}));
  }

  /**
   * Recreate the pattern from rules list
   */
  _createClass(Isbot, [{
    key: "pattern",
    get:
    /**
     * Get a clone of the pattern
     * @type RegExp
     */
    function get() {
      return new RegExp(_classPrivateFieldGet(this, _pattern));
    }

    /**
     * Match given string against out pattern
     * @param  {string} ua User Agent string
     * @returns {boolean}
     */
  }, {
    key: "test",
    value: function test(ua) {
      return Boolean(ua) && _classPrivateFieldGet(this, _pattern).test(ua);
    }

    /**
     * Get the match for strings' known crawler pattern
     * @param  {string} ua User Agent string
     * @returns {string|null}
     */
  }, {
    key: "find",
    value: function find() {
      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var match = ua.match(_classPrivateFieldGet(this, _pattern));
      return match && match[0];
    }

    /**
     * Get the patterns that match user agent string if any
     * @param  {string} ua User Agent string
     * @returns {string[]}
     */
  }, {
    key: "matches",
    value: function matches() {
      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return _classPrivateFieldGet(this, _list).filter(function (entry) {
        return new RegExp(entry, flags).test(ua);
      });
    }

    /**
     * Clear all patterns that match user agent
     * @param  {string} ua User Agent string
     * @returns {void}
     */
  }, {
    key: "clear",
    value: function clear() {
      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this.exclude(this.matches(ua));
    }

    /**
     * Extent patterns for known crawlers
     * @param  {string[]} filters
     * @returns {void}
     */
  }, {
    key: "extend",
    value: function extend() {
      var _this2 = this;
      var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      [].push.apply(_classPrivateFieldGet(this, _list), filters.filter(function (rule) {
        return _classPrivateMethodGet(_this2, _index, _index2).call(_this2, rule) === -1;
      }).map(function (filter) {
        return filter.toLowerCase();
      }));
      _classPrivateMethodGet(this, _update, _update2).call(this);
    }

    /**
     * Exclude patterns from bot pattern rule
     * @param  {string[]} filters
     * @returns {void}
     */
  }, {
    key: "exclude",
    value: function exclude() {
      var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var length = filters.length;
      while (length--) {
        var index = _classPrivateMethodGet(this, _index, _index2).call(this, filters[length]);
        if (index > -1) {
          _classPrivateFieldGet(this, _list).splice(index, 1);
        }
      }
      _classPrivateMethodGet(this, _update, _update2).call(this);
    }

    /**
     * Create a new Isbot instance using given list or self's list
     * @param  {string[]} [list]
     * @returns {Isbot}
     */
  }, {
    key: "spawn",
    value: function spawn(list) {
      return new Isbot(list || _classPrivateFieldGet(this, _list));
    }
  }]);
  return Isbot;
}();
function _update2() {
  _classPrivateFieldSet(this, _pattern, new RegExp(_classPrivateFieldGet(this, _list).join('|'), flags));
}
function _index2(rule) {
  return _classPrivateFieldGet(this, _list).indexOf(rule.toLowerCase());
}

var isbot = new Isbot();

module.exports = isbot;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 405:
/***/ ((module) => {

module.exports = debounce;

function debounce(fn, delay, atStart, guarantee) {
  var timeout;
  var args;
  var self;

  return function debounced() {
    self = this;
    args = Array.prototype.slice.call(arguments);

    if (timeout && (atStart || guarantee)) {
      return;
    } else if (!atStart) {
      clear();

      timeout = setTimeout(run, delay);
      return timeout;
    }

    timeout = setTimeout(clear, delay);
    fn.apply(self, args);

    function run() {
      clear();
      fn.apply(self, args);
    }

    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}


/***/ }),

/***/ 265:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_543__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_543__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_543__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_543__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_543__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_543__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_543__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_543__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_543__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_543__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_543__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_543__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_543__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_543__(__nested_webpack_require_543__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4019__) {

"use strict";
__nested_webpack_require_4019__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/tools.js
var argumentAsArray = function argumentAsArray(argument) {
  return Array.isArray(argument) ? argument : [argument];
};
var isElement = function isElement(target) {
  return target instanceof Node;
};
var isElementList = function isElementList(nodeList) {
  return nodeList instanceof NodeList;
};
var eachNode = function eachNode(nodeList, callback) {
  if (nodeList && callback) {
    nodeList = isElementList(nodeList) ? nodeList : [nodeList];

    for (var i = 0; i < nodeList.length; i++) {
      if (callback(nodeList[i], i, nodeList.length) === true) {
        break;
      }
    }
  }
};
var throwError = function throwError(message) {
  return console.error("[scroll-lock] ".concat(message));
};
var arrayAsSelector = function arrayAsSelector(array) {
  if (Array.isArray(array)) {
    var selector = array.join(', ');
    return selector;
  }
};
var nodeListAsArray = function nodeListAsArray(nodeList) {
  var nodes = [];
  eachNode(nodeList, function (node) {
    return nodes.push(node);
  });
  return nodes;
};
var findParentBySelector = function findParentBySelector($el, selector) {
  var self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var $root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : document;

  if (self && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1) {
    return $el;
  }

  while (($el = $el.parentElement) && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) === -1) {
    ;
  }

  return $el;
};
var elementHasSelector = function elementHasSelector($el, selector) {
  var $root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
  var has = nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1;
  return has;
};
var elementHasOverflowHidden = function elementHasOverflowHidden($el) {
  if ($el) {
    var computedStyle = getComputedStyle($el);
    var overflowIsHidden = computedStyle.overflow === 'hidden';
    return overflowIsHidden;
  }
};
var elementScrollTopOnStart = function elementScrollTopOnStart($el) {
  if ($el) {
    if (elementHasOverflowHidden($el)) {
      return true;
    }

    var scrollTop = $el.scrollTop;
    return scrollTop <= 0;
  }
};
var elementScrollTopOnEnd = function elementScrollTopOnEnd($el) {
  if ($el) {
    if (elementHasOverflowHidden($el)) {
      return true;
    }

    var scrollTop = $el.scrollTop;
    var scrollHeight = $el.scrollHeight;
    var scrollTopWithHeight = scrollTop + $el.offsetHeight;
    return scrollTopWithHeight >= scrollHeight;
  }
};
var elementScrollLeftOnStart = function elementScrollLeftOnStart($el) {
  if ($el) {
    if (elementHasOverflowHidden($el)) {
      return true;
    }

    var scrollLeft = $el.scrollLeft;
    return scrollLeft <= 0;
  }
};
var elementScrollLeftOnEnd = function elementScrollLeftOnEnd($el) {
  if ($el) {
    if (elementHasOverflowHidden($el)) {
      return true;
    }

    var scrollLeft = $el.scrollLeft;
    var scrollWidth = $el.scrollWidth;
    var scrollLeftWithWidth = scrollLeft + $el.offsetWidth;
    return scrollLeftWithWidth >= scrollWidth;
  }
};
var elementIsScrollableField = function elementIsScrollableField($el) {
  var selector = 'textarea, [contenteditable="true"]';
  return elementHasSelector($el, selector);
};
var elementIsInputRange = function elementIsInputRange($el) {
  var selector = 'input[type="range"]';
  return elementHasSelector($el, selector);
};
// CONCATENATED MODULE: ./src/scroll-lock.js
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "disablePageScroll", function() { return disablePageScroll; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "enablePageScroll", function() { return enablePageScroll; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "getScrollState", function() { return getScrollState; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "clearQueueScrollLocks", function() { return clearQueueScrollLocks; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "getTargetScrollBarWidth", function() { return scroll_lock_getTargetScrollBarWidth; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "getCurrentTargetScrollBarWidth", function() { return scroll_lock_getCurrentTargetScrollBarWidth; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "getPageScrollBarWidth", function() { return getPageScrollBarWidth; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "getCurrentPageScrollBarWidth", function() { return getCurrentPageScrollBarWidth; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "addScrollableTarget", function() { return scroll_lock_addScrollableTarget; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "removeScrollableTarget", function() { return scroll_lock_removeScrollableTarget; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "addScrollableSelector", function() { return scroll_lock_addScrollableSelector; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "removeScrollableSelector", function() { return scroll_lock_removeScrollableSelector; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "addLockableTarget", function() { return scroll_lock_addLockableTarget; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "addLockableSelector", function() { return scroll_lock_addLockableSelector; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "setFillGapMethod", function() { return scroll_lock_setFillGapMethod; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "addFillGapTarget", function() { return scroll_lock_addFillGapTarget; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "removeFillGapTarget", function() { return scroll_lock_removeFillGapTarget; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "addFillGapSelector", function() { return scroll_lock_addFillGapSelector; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "removeFillGapSelector", function() { return scroll_lock_removeFillGapSelector; });
/* harmony export (binding) */ __nested_webpack_require_4019__.d(__webpack_exports__, "refillGaps", function() { return refillGaps; });
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var FILL_GAP_AVAILABLE_METHODS = ['padding', 'margin', 'width', 'max-width', 'none'];
var TOUCH_DIRECTION_DETECT_OFFSET = 3;
var state = {
  scroll: true,
  queue: 0,
  scrollableSelectors: ['[data-scroll-lock-scrollable]'],
  lockableSelectors: ['body', '[data-scroll-lock-lockable]'],
  fillGapSelectors: ['body', '[data-scroll-lock-fill-gap]', '[data-scroll-lock-lockable]'],
  fillGapMethod: FILL_GAP_AVAILABLE_METHODS[0],
  //
  startTouchY: 0,
  startTouchX: 0
};
var disablePageScroll = function disablePageScroll(target) {
  if (state.queue <= 0) {
    state.scroll = false;
    scroll_lock_hideLockableOverflow();
    fillGaps();
  }

  scroll_lock_addScrollableTarget(target);
  state.queue++;
};
var enablePageScroll = function enablePageScroll(target) {
  state.queue > 0 && state.queue--;

  if (state.queue <= 0) {
    state.scroll = true;
    scroll_lock_showLockableOverflow();
    unfillGaps();
  }

  scroll_lock_removeScrollableTarget(target);
};
var getScrollState = function getScrollState() {
  return state.scroll;
};
var clearQueueScrollLocks = function clearQueueScrollLocks() {
  state.queue = 0;
};
var scroll_lock_getTargetScrollBarWidth = function getTargetScrollBarWidth($target) {
  var onlyExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (isElement($target)) {
    var currentOverflowYProperty = $target.style.overflowY;

    if (onlyExists) {
      if (!getScrollState()) {
        $target.style.overflowY = $target.getAttribute('data-scroll-lock-saved-overflow-y-property');
      }
    } else {
      $target.style.overflowY = 'scroll';
    }

    var width = scroll_lock_getCurrentTargetScrollBarWidth($target);
    $target.style.overflowY = currentOverflowYProperty;
    return width;
  } else {
    return 0;
  }
};
var scroll_lock_getCurrentTargetScrollBarWidth = function getCurrentTargetScrollBarWidth($target) {
  if (isElement($target)) {
    if ($target === document.body) {
      var documentWidth = document.documentElement.clientWidth;
      var windowWidth = window.innerWidth;
      var currentWidth = windowWidth - documentWidth;
      return currentWidth;
    } else {
      var borderLeftWidthCurrentProperty = $target.style.borderLeftWidth;
      var borderRightWidthCurrentProperty = $target.style.borderRightWidth;
      $target.style.borderLeftWidth = '0px';
      $target.style.borderRightWidth = '0px';

      var _currentWidth = $target.offsetWidth - $target.clientWidth;

      $target.style.borderLeftWidth = borderLeftWidthCurrentProperty;
      $target.style.borderRightWidth = borderRightWidthCurrentProperty;
      return _currentWidth;
    }
  } else {
    return 0;
  }
};
var getPageScrollBarWidth = function getPageScrollBarWidth() {
  var onlyExists = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return scroll_lock_getTargetScrollBarWidth(document.body, onlyExists);
};
var getCurrentPageScrollBarWidth = function getCurrentPageScrollBarWidth() {
  return scroll_lock_getCurrentTargetScrollBarWidth(document.body);
};
var scroll_lock_addScrollableTarget = function addScrollableTarget(target) {
  if (target) {
    var targets = argumentAsArray(target);
    targets.map(function ($targets) {
      eachNode($targets, function ($target) {
        if (isElement($target)) {
          $target.setAttribute('data-scroll-lock-scrollable', '');
        } else {
          throwError("\"".concat($target, "\" is not a Element."));
        }
      });
    });
  }
};
var scroll_lock_removeScrollableTarget = function removeScrollableTarget(target) {
  if (target) {
    var targets = argumentAsArray(target);
    targets.map(function ($targets) {
      eachNode($targets, function ($target) {
        if (isElement($target)) {
          $target.removeAttribute('data-scroll-lock-scrollable');
        } else {
          throwError("\"".concat($target, "\" is not a Element."));
        }
      });
    });
  }
};
var scroll_lock_addScrollableSelector = function addScrollableSelector(selector) {
  if (selector) {
    var selectors = argumentAsArray(selector);
    selectors.map(function (selector) {
      state.scrollableSelectors.push(selector);
    });
  }
};
var scroll_lock_removeScrollableSelector = function removeScrollableSelector(selector) {
  if (selector) {
    var selectors = argumentAsArray(selector);
    selectors.map(function (selector) {
      state.scrollableSelectors = state.scrollableSelectors.filter(function (sSelector) {
        return sSelector !== selector;
      });
    });
  }
};
var scroll_lock_addLockableTarget = function addLockableTarget(target) {
  if (target) {
    var targets = argumentAsArray(target);
    targets.map(function ($targets) {
      eachNode($targets, function ($target) {
        if (isElement($target)) {
          $target.setAttribute('data-scroll-lock-lockable', '');
        } else {
          throwError("\"".concat($target, "\" is not a Element."));
        }
      });
    });

    if (!getScrollState()) {
      scroll_lock_hideLockableOverflow();
    }
  }
};
var scroll_lock_addLockableSelector = function addLockableSelector(selector) {
  if (selector) {
    var selectors = argumentAsArray(selector);
    selectors.map(function (selector) {
      state.lockableSelectors.push(selector);
    });

    if (!getScrollState()) {
      scroll_lock_hideLockableOverflow();
    }

    scroll_lock_addFillGapSelector(selector);
  }
};
var scroll_lock_setFillGapMethod = function setFillGapMethod(method) {
  if (method) {
    if (FILL_GAP_AVAILABLE_METHODS.indexOf(method) !== -1) {
      state.fillGapMethod = method;
      refillGaps();
    } else {
      var methods = FILL_GAP_AVAILABLE_METHODS.join(', ');
      throwError("\"".concat(method, "\" method is not available!\nAvailable fill gap methods: ").concat(methods, "."));
    }
  }
};
var scroll_lock_addFillGapTarget = function addFillGapTarget(target) {
  if (target) {
    var targets = argumentAsArray(target);
    targets.map(function ($targets) {
      eachNode($targets, function ($target) {
        if (isElement($target)) {
          $target.setAttribute('data-scroll-lock-fill-gap', '');

          if (!state.scroll) {
            scroll_lock_fillGapTarget($target);
          }
        } else {
          throwError("\"".concat($target, "\" is not a Element."));
        }
      });
    });
  }
};
var scroll_lock_removeFillGapTarget = function removeFillGapTarget(target) {
  if (target) {
    var targets = argumentAsArray(target);
    targets.map(function ($targets) {
      eachNode($targets, function ($target) {
        if (isElement($target)) {
          $target.removeAttribute('data-scroll-lock-fill-gap');

          if (!state.scroll) {
            scroll_lock_unfillGapTarget($target);
          }
        } else {
          throwError("\"".concat($target, "\" is not a Element."));
        }
      });
    });
  }
};
var scroll_lock_addFillGapSelector = function addFillGapSelector(selector) {
  if (selector) {
    var selectors = argumentAsArray(selector);
    selectors.map(function (selector) {
      if (state.fillGapSelectors.indexOf(selector) === -1) {
        state.fillGapSelectors.push(selector);

        if (!state.scroll) {
          scroll_lock_fillGapSelector(selector);
        }
      }
    });
  }
};
var scroll_lock_removeFillGapSelector = function removeFillGapSelector(selector) {
  if (selector) {
    var selectors = argumentAsArray(selector);
    selectors.map(function (selector) {
      state.fillGapSelectors = state.fillGapSelectors.filter(function (fSelector) {
        return fSelector !== selector;
      });

      if (!state.scroll) {
        scroll_lock_unfillGapSelector(selector);
      }
    });
  }
};
var refillGaps = function refillGaps() {
  if (!state.scroll) {
    fillGaps();
  }
};

var scroll_lock_hideLockableOverflow = function hideLockableOverflow() {
  var selector = arrayAsSelector(state.lockableSelectors);
  scroll_lock_hideLockableOverflowSelector(selector);
};

var scroll_lock_showLockableOverflow = function showLockableOverflow() {
  var selector = arrayAsSelector(state.lockableSelectors);
  scroll_lock_showLockableOverflowSelector(selector);
};

var scroll_lock_hideLockableOverflowSelector = function hideLockableOverflowSelector(selector) {
  var $targets = document.querySelectorAll(selector);
  eachNode($targets, function ($target) {
    scroll_lock_hideLockableOverflowTarget($target);
  });
};

var scroll_lock_showLockableOverflowSelector = function showLockableOverflowSelector(selector) {
  var $targets = document.querySelectorAll(selector);
  eachNode($targets, function ($target) {
    scroll_lock_showLockableOverflowTarget($target);
  });
};

var scroll_lock_hideLockableOverflowTarget = function hideLockableOverflowTarget($target) {
  if (isElement($target) && $target.getAttribute('data-scroll-lock-locked') !== 'true') {
    var computedStyle = window.getComputedStyle($target);
    $target.setAttribute('data-scroll-lock-saved-overflow-y-property', computedStyle.overflowY);
    $target.setAttribute('data-scroll-lock-saved-inline-overflow-property', $target.style.overflow);
    $target.setAttribute('data-scroll-lock-saved-inline-overflow-y-property', $target.style.overflowY);
    $target.style.overflow = 'hidden';
    $target.setAttribute('data-scroll-lock-locked', 'true');
  }
};

var scroll_lock_showLockableOverflowTarget = function showLockableOverflowTarget($target) {
  if (isElement($target) && $target.getAttribute('data-scroll-lock-locked') === 'true') {
    $target.style.overflow = $target.getAttribute('data-scroll-lock-saved-inline-overflow-property');
    $target.style.overflowY = $target.getAttribute('data-scroll-lock-saved-inline-overflow-y-property');
    $target.removeAttribute('data-scroll-lock-saved-overflow-property');
    $target.removeAttribute('data-scroll-lock-saved-inline-overflow-property');
    $target.removeAttribute('data-scroll-lock-saved-inline-overflow-y-property');
    $target.removeAttribute('data-scroll-lock-locked');
  }
};

var fillGaps = function fillGaps() {
  state.fillGapSelectors.map(function (selector) {
    scroll_lock_fillGapSelector(selector);
  });
};

var unfillGaps = function unfillGaps() {
  state.fillGapSelectors.map(function (selector) {
    scroll_lock_unfillGapSelector(selector);
  });
};

var scroll_lock_fillGapSelector = function fillGapSelector(selector) {
  var $targets = document.querySelectorAll(selector);
  var isLockable = state.lockableSelectors.indexOf(selector) !== -1;
  eachNode($targets, function ($target) {
    scroll_lock_fillGapTarget($target, isLockable);
  });
};

var scroll_lock_fillGapTarget = function fillGapTarget($target) {
  var isLockable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (isElement($target)) {
    var scrollBarWidth;

    if ($target.getAttribute('data-scroll-lock-lockable') === '' || isLockable) {
      scrollBarWidth = scroll_lock_getTargetScrollBarWidth($target, true);
    } else {
      var $lockableParent = findParentBySelector($target, arrayAsSelector(state.lockableSelectors));
      scrollBarWidth = scroll_lock_getTargetScrollBarWidth($lockableParent, true);
    }

    if ($target.getAttribute('data-scroll-lock-filled-gap') === 'true') {
      scroll_lock_unfillGapTarget($target);
    }

    var computedStyle = window.getComputedStyle($target);
    $target.setAttribute('data-scroll-lock-filled-gap', 'true');
    $target.setAttribute('data-scroll-lock-current-fill-gap-method', state.fillGapMethod);

    if (state.fillGapMethod === 'margin') {
      var currentMargin = parseFloat(computedStyle.marginRight);
      $target.style.marginRight = "".concat(currentMargin + scrollBarWidth, "px");
    } else if (state.fillGapMethod === 'width') {
      $target.style.width = "calc(100% - ".concat(scrollBarWidth, "px)");
    } else if (state.fillGapMethod === 'max-width') {
      $target.style.maxWidth = "calc(100% - ".concat(scrollBarWidth, "px)");
    } else if (state.fillGapMethod === 'padding') {
      var currentPadding = parseFloat(computedStyle.paddingRight);
      $target.style.paddingRight = "".concat(currentPadding + scrollBarWidth, "px");
    }
  }
};

var scroll_lock_unfillGapSelector = function unfillGapSelector(selector) {
  var $targets = document.querySelectorAll(selector);
  eachNode($targets, function ($target) {
    scroll_lock_unfillGapTarget($target);
  });
};

var scroll_lock_unfillGapTarget = function unfillGapTarget($target) {
  if (isElement($target)) {
    if ($target.getAttribute('data-scroll-lock-filled-gap') === 'true') {
      var currentFillGapMethod = $target.getAttribute('data-scroll-lock-current-fill-gap-method');
      $target.removeAttribute('data-scroll-lock-filled-gap');
      $target.removeAttribute('data-scroll-lock-current-fill-gap-method');

      if (currentFillGapMethod === 'margin') {
        $target.style.marginRight = "";
      } else if (currentFillGapMethod === 'width') {
        $target.style.width = "";
      } else if (currentFillGapMethod === 'max-width') {
        $target.style.maxWidth = "";
      } else if (currentFillGapMethod === 'padding') {
        $target.style.paddingRight = "";
      }
    }
  }
};

var onResize = function onResize(e) {
  refillGaps();
};

var onTouchStart = function onTouchStart(e) {
  if (!state.scroll) {
    state.startTouchY = e.touches[0].clientY;
    state.startTouchX = e.touches[0].clientX;
  }
};

var scroll_lock_onTouchMove = function onTouchMove(e) {
  if (!state.scroll) {
    var startTouchY = state.startTouchY,
        startTouchX = state.startTouchX;
    var currentClientY = e.touches[0].clientY;
    var currentClientX = e.touches[0].clientX;

    if (e.touches.length < 2) {
      var selector = arrayAsSelector(state.scrollableSelectors);
      var direction = {
        up: startTouchY < currentClientY,
        down: startTouchY > currentClientY,
        left: startTouchX < currentClientX,
        right: startTouchX > currentClientX
      };
      var directionWithOffset = {
        up: startTouchY + TOUCH_DIRECTION_DETECT_OFFSET < currentClientY,
        down: startTouchY - TOUCH_DIRECTION_DETECT_OFFSET > currentClientY,
        left: startTouchX + TOUCH_DIRECTION_DETECT_OFFSET < currentClientX,
        right: startTouchX - TOUCH_DIRECTION_DETECT_OFFSET > currentClientX
      };

      var handle = function handle($el) {
        var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if ($el) {
          var parentScrollableEl = findParentBySelector($el, selector, false);

          if (elementIsInputRange($el)) {
            return false;
          }

          if (skip || elementIsScrollableField($el) && findParentBySelector($el, selector) || elementHasSelector($el, selector)) {
            var prevent = false;

            if (elementScrollLeftOnStart($el) && elementScrollLeftOnEnd($el)) {
              if (direction.up && elementScrollTopOnStart($el) || direction.down && elementScrollTopOnEnd($el)) {
                prevent = true;
              }
            } else if (elementScrollTopOnStart($el) && elementScrollTopOnEnd($el)) {
              if (direction.left && elementScrollLeftOnStart($el) || direction.right && elementScrollLeftOnEnd($el)) {
                prevent = true;
              }
            } else if (directionWithOffset.up && elementScrollTopOnStart($el) || directionWithOffset.down && elementScrollTopOnEnd($el) || directionWithOffset.left && elementScrollLeftOnStart($el) || directionWithOffset.right && elementScrollLeftOnEnd($el)) {
              prevent = true;
            }

            if (prevent) {
              if (parentScrollableEl) {
                handle(parentScrollableEl, true);
              } else {
                if (e.cancelable) {
                  e.preventDefault();
                }
              }
            }
          } else {
            handle(parentScrollableEl);
          }
        } else {
          if (e.cancelable) {
            e.preventDefault();
          }
        }
      };

      handle(e.target);
    }
  }
};

var onTouchEnd = function onTouchEnd(e) {
  if (!state.scroll) {
    state.startTouchY = 0;
    state.startTouchX = 0;
  }
};

if (typeof window !== 'undefined') {
  window.addEventListener('resize', onResize);
}

if (typeof document !== 'undefined') {
  document.addEventListener('touchstart', onTouchStart);
  document.addEventListener('touchmove', scroll_lock_onTouchMove, {
    passive: false
  });
  document.addEventListener('touchend', onTouchEnd);
}

var deprecatedMethods = {
  hide: function hide(target) {
    throwError('"hide" is deprecated! Use "disablePageScroll" instead. \n https://github.com/FL3NKEY/scroll-lock#disablepagescrollscrollabletarget');
    disablePageScroll(target);
  },
  show: function show(target) {
    throwError('"show" is deprecated! Use "enablePageScroll" instead. \n https://github.com/FL3NKEY/scroll-lock#enablepagescrollscrollabletarget');
    enablePageScroll(target);
  },
  toggle: function toggle(target) {
    throwError('"toggle" is deprecated! Do not use it.');

    if (getScrollState()) {
      disablePageScroll();
    } else {
      enablePageScroll(target);
    }
  },
  getState: function getState() {
    throwError('"getState" is deprecated! Use "getScrollState" instead. \n https://github.com/FL3NKEY/scroll-lock#getscrollstate');
    return getScrollState();
  },
  getWidth: function getWidth() {
    throwError('"getWidth" is deprecated! Use "getPageScrollBarWidth" instead. \n https://github.com/FL3NKEY/scroll-lock#getpagescrollbarwidth');
    return getPageScrollBarWidth();
  },
  getCurrentWidth: function getCurrentWidth() {
    throwError('"getCurrentWidth" is deprecated! Use "getCurrentPageScrollBarWidth" instead. \n https://github.com/FL3NKEY/scroll-lock#getcurrentpagescrollbarwidth');
    return getCurrentPageScrollBarWidth();
  },
  setScrollableTargets: function setScrollableTargets(target) {
    throwError('"setScrollableTargets" is deprecated! Use "addScrollableTarget" instead. \n https://github.com/FL3NKEY/scroll-lock#addscrollabletargetscrollabletarget');
    scroll_lock_addScrollableTarget(target);
  },
  setFillGapSelectors: function setFillGapSelectors(selector) {
    throwError('"setFillGapSelectors" is deprecated! Use "addFillGapSelector" instead. \n https://github.com/FL3NKEY/scroll-lock#addfillgapselectorfillgapselector');
    scroll_lock_addFillGapSelector(selector);
  },
  setFillGapTargets: function setFillGapTargets(target) {
    throwError('"setFillGapTargets" is deprecated! Use "addFillGapTarget" instead. \n https://github.com/FL3NKEY/scroll-lock#addfillgaptargetfillgaptarget');
    scroll_lock_addFillGapTarget(target);
  },
  clearQueue: function clearQueue() {
    throwError('"clearQueue" is deprecated! Use "clearQueueScrollLocks" instead. \n https://github.com/FL3NKEY/scroll-lock#clearqueuescrolllocks');
    clearQueueScrollLocks();
  }
};

var scrollLock = _objectSpread({
  disablePageScroll: disablePageScroll,
  enablePageScroll: enablePageScroll,
  getScrollState: getScrollState,
  clearQueueScrollLocks: clearQueueScrollLocks,
  getTargetScrollBarWidth: scroll_lock_getTargetScrollBarWidth,
  getCurrentTargetScrollBarWidth: scroll_lock_getCurrentTargetScrollBarWidth,
  getPageScrollBarWidth: getPageScrollBarWidth,
  getCurrentPageScrollBarWidth: getCurrentPageScrollBarWidth,
  addScrollableSelector: scroll_lock_addScrollableSelector,
  removeScrollableSelector: scroll_lock_removeScrollableSelector,
  addScrollableTarget: scroll_lock_addScrollableTarget,
  removeScrollableTarget: scroll_lock_removeScrollableTarget,
  addLockableSelector: scroll_lock_addLockableSelector,
  addLockableTarget: scroll_lock_addLockableTarget,
  addFillGapSelector: scroll_lock_addFillGapSelector,
  removeFillGapSelector: scroll_lock_removeFillGapSelector,
  addFillGapTarget: scroll_lock_addFillGapTarget,
  removeFillGapTarget: scroll_lock_removeFillGapTarget,
  setFillGapMethod: scroll_lock_setFillGapMethod,
  refillGaps: refillGaps,
  _state: state
}, deprecatedMethods);

/* harmony default export */ var scroll_lock = __webpack_exports__["default"] = (scrollLock);

/***/ })
/******/ ])["default"];
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
(() => {
(function (n, v) {
    // eslint-disable-next-line max-len
    if (window.Shopify && window.Shopify.theme && navigator && navigator.sendBeacon && window.Shopify.designMode) {
      if (sessionStorage.getItem('oots_beacon')) return;

      navigator.sendBeacon('https://app.outofthesandbox.com/beacon', new URLSearchParams({
        shop_domain: window.Shopify.shop,
        shop_id: window.Store.id,
        theme_name: n,
        theme_version: v,
        theme_store_id: window.Shopify.theme.theme_store_id,
        theme_id: window.Shopify.theme.id,
        theme_role: window.Shopify.theme.role,
      }));

      sessionStorage.setItem('oots_beacon', '');
    }
  }('responsive','9.1.0'))
})();

(() => {
"use strict";
/* harmony import */ var _pixelunion_rimg_shopify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(598);
/* harmony import */ var _pixelunion_shopify_sections_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _pixelunion_age_gate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(812);
/* harmony import */ var _pixelunion_shopify_surface_pick_up__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(923);
/* harmony import */ var just_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(405);
/* harmony import */ var just_debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(just_debounce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _pixelunion_events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(766);
/* harmony import */ var _pixelunion_animations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(569);
/* harmony import */ var _pixelunion_shopify_asyncview__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(187);
/* harmony import */ var _helpers_ComplementaryProducts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(463);
/* harmony import */ var _helpers_PaymentTerms__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(880);
/* harmony import */ var _helpers_RecipientForm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(680);
/* harmony import */ var _helpers_ShippingCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(581);












_pixelunion_rimg_shopify__WEBPACK_IMPORTED_MODULE_0__/* .default.init */ .Z.init('[data-rimg="lazy"]', {
  round: 1
});
const sections = new _pixelunion_shopify_sections_manager__WEBPACK_IMPORTED_MODULE_8__/* .default */ .Z();
sections.register('age-gate', section => new _pixelunion_age_gate__WEBPACK_IMPORTED_MODULE_1__/* .PageAgeGate */ .h(section));
const ageGatePage = document.getElementById('age-gate-page');

if (ageGatePage) {
  new _pixelunion_age_gate__WEBPACK_IMPORTED_MODULE_1__/* .SiteAgeGate */ .G(ageGatePage);
}
/*============================================================================
  Global - header
==============================================================================*/


window.header = {
  init: function () {
    // Add margin to the header logo
    if ($('.top-bar').hasClass('top-bar--fixed-true top-bar--announcement-bar--false')) {
      var topBarHeight = $('.top-bar').outerHeight();
      $('.top-bar').css('position', 'fixed');
      $('.header-logo').css('margin-top', topBarHeight);
    } // Add margin to the header logo on resize


    $(window).resize(function () {
      if ($('.top-bar').hasClass('top-bar--fixed-true top-bar--announcement-bar--false')) {
        var topBarHeight = $('.top-bar').outerHeight();
        $('.top-bar').css('position', 'fixed');
        $('.header-logo').css('margin-top', topBarHeight);
      }
    });
    /* Promotional Banner */

    if ($('.announcementBar').length) {
      var promo_banner = Cookies.get('promo_banner');

      if (promo_banner != 'dismiss') {
        $('body').addClass('promo_banner-show');
        $('.announcementBar').on('click', '.banner-close', function () {
          $('body').removeClass('promo_banner-show');
          Cookies.set('promo_banner', 'dismiss', {
            expires: 30
          });
        });
      }
    } //Scroll check for sticky topbar with announcement


    if ($('.announcementBar').length && $('.top-bar--fixed-true').length) {
      var announcementBarHeight = $('.announcementBar').height();
      $(window).scroll(function () {
        if ($(this).scrollTop() >= announcementBarHeight) {
          $('.top-bar--fixed-true').css({
            'position': 'fixed',
            'top': '0'
          });
          $('.announcementBar').css('margin-bottom', announcementBarHeight);
        } else {
          $('.top-bar--fixed-true').css('position', 'relative');
          $('.announcementBar').css('margin-bottom', '0');
        }
      });
    } // Anchor link smooth scroll to avoid text cutoff


    if ($('.top-bar').hasClass('top-bar--fixed-true')) {
      $('#menu li a[href^="#"]').on('click', function (e) {
        e.preventDefault();
        var winScroll = $(window).scrollTop();
        var anchorlink = $(this).attr('href');
        var headerHeight = $('.top-bar').outerHeight();
        $('html, body').animate({
          scrollTop: $(anchorlink).offset().top - headerHeight
        }, 2000);
      });
    }

    ; //Init Menu

    $('.menu-mobile').slicknav({
      init: function () {
        $('.mobile_currency').detach().appendTo($('.slicknav_nav'));
      },
      prependTo: '#mobile_nav',
      label: '<div aria-haspopup="true" role="navigation" aria-label="' + window.PXUTheme.translation.menu + '"><span class="icon-menu"></span> ' + window.PXUTheme.translation.menu + '</div>',
      closedSymbol: '<span class="icon-right-arrow menu-icon" aria-haspopup="true" aria-expanded="false"></span>',
      openedSymbol: '<span class="icon-down-arrow menu-icon" aria-haspopup="true" aria-expanded="true"></span>',
      allowParentLinks: true,
      nestedParentLinks: false,
      afterOpen: function (trigger) {
        $(trigger).parents('.slicknav_parent').first().addClass('slicknav_open');
        $(trigger).parents('.slicknav_parent').first().removeClass('slicknav_collapsed');
        $(trigger).siblings('.slicknav_item').find('.slicknav_arrow span').removeClass('icon-right-arrow');
        $(trigger).siblings('.slicknav_item').find('.slicknav_arrow span').addClass('icon-down-arrow');
      },
      beforeClose: function (trigger) {
        $(trigger).parents('.slicknav_parent').first().removeClass('slicknav_open');
        $(trigger).parents('.slicknav_parent').first().addClass('slicknav_collapsed');
        $(trigger).siblings('.slicknav_item').find('.slicknav_arrow span').addClass('icon-right-arrow');
        $(trigger).siblings('.slicknav_item').find('.slicknav_arrow span').removeClass('icon-down-arrow');
      }
    });

    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && window.PXUTheme.media_queries.large.matches) {
      $(document).on('click', 'li.sub-menu a.sub-menu--link', function (e) {
        var dropdownUrl = $(this).attr('href');

        if ($(this).hasClass('click-active')) {
          window.location.href = dropdownUrl;
          $('#nav ul li a').removeClass('click-active');
        } else {
          $('#nav ul li a').removeClass('click-active');
          $(this).addClass('click-active');
        }

        e.preventDefault();
        return false;
      });
    } // Handle clicking parent link with dropdowns


    const detailsElements = document.querySelectorAll('#menu li [data-nav-details]');
    const firstLevelDetails = [...document.querySelectorAll('#menu > li > [data-nav-details]')];

    function handleDetailsClick(e) {
      e.stopPropagation();
      const clickedParent = e.target.closest('li.sub-menu') ? e.target.closest('li.sub-menu') : e.target.closest('megaMenu-dropdown.parent-link--true');
      const clickedDetail = e.currentTarget; // Close Siblings

      if (firstLevelDetails.includes(clickedDetail)) {
        firstLevelDetails.forEach(detailsElement => {
          if (detailsElement !== clickedDetail) {
            detailsElement.open = false;
          }
        });
      }

      if (clickedParent && e.target.getAttribute('href')) {
        e.preventDefault();

        if (clickedDetail.open) {
          window.location = e.target.getAttribute('href');
          return;
        } // If the submenu isn't open, open it


        clickedDetail.open = true;
      }
    }

    detailsElements.forEach(element => element.addEventListener('click', handleDetailsClick));
    detailsElements.forEach(element => element.addEventListener('touchend', handleDetailsClick)); // Remove simplebar menu from mega menu on mobile

    var $megaMenu = $('#mobile_nav').find('.megaMenu-grid-wrap');
    $megaMenu.attr('data-simplebar', '');
    $megaMenu.attr('data-simplebar-auto-hide', '');
    $('#menu [aria-haspopup]').on('mouseenter', function () {
      $(this).attr('aria-expanded', true);
      const $detailsEl = $(this).find('[data-nav-details]').first();

      if ($detailsEl) {
        $detailsEl.each((_, $details) => {
          $details.open = true;
        });
      }
    });
    $('#menu [aria-haspopup]').on('mouseleave', function () {
      $(this).attr('aria-expanded', false);
      const $detailsEl = $(this).find('details').first();

      if ($detailsEl) {
        $detailsEl.each((_, $details) => {
          $details.open = false;
        });
      }
    });
    $('body').on('mouseover', '.js-megaMenu', function () {
      $(this).prev('.sub-menu').attr('aria-expanded', true);
    });
    $('body').on('mouseout', '.js-megaMenu', function () {
      $(this).prev('.sub-menu').attr('aria-expanded', false);
    }); //Mobile mega menu bindings
    //No parent link (eg. /, #, '')

    $('#mobile_nav .js-megaMenu-dropdown.parent-link--false').on('click', function () {
      var dropdown = $(this);
      var arrow = $(this).find('.arrow');

      if (dropdown.find('.megaMenu-sub-submenu').length) {
        var submenu = dropdown.find('.megaMenu-sub-submenu');
      } else {
        var submenu = dropdown.next();
      }

      submenu.slideToggle('fast');
      arrow.toggleClass('icon-right-arrow');
      arrow.toggleClass('icon-down-arrow');
      dropdown.toggleClass('dropdown--active');
    }); //Active parent link

    $('#mobile_nav .js-megaMenu-dropdown.parent-link--true .arrow').on('click', function () {
      var dropdown = $(this).parent('.js-megaMenu-dropdown');
      var arrow = $(this);

      if (dropdown.find('.megaMenu-sub-submenu').length) {
        var submenu = dropdown.find('.megaMenu-sub-submenu');
      } else {
        var submenu = dropdown.next();
      }

      submenu.slideToggle('fast');
      arrow.toggleClass('icon-right-arrow');
      arrow.toggleClass('icon-down-arrow');
      dropdown.toggleClass('dropdown--active');
    }); //Detect hover in for mega menu

    $('#nav .js-megaMenu .megaMenu-dropdown').on('mouseenter', function () {
      $(this).addClass('dropdown--active');

      if ($(this).find('span').hasClass('icon-right-arrow')) {
        $(this).find('span').removeClass('icon-right-arrow').addClass('icon-down-arrow');
        $(this).find('.megaMenu-sub-submenu').stop().slideToggle();
      }

      const $detailsEl = $(this).find('[data-nav-details]').first();

      if ($detailsEl) {
        $detailsEl.each((_, $details) => {
          $details.open = true;
        });
      }
    }); //Detect hover out for mega menu

    $('#nav .js-megaMenu .megaMenu-dropdown').on('mouseleave', function () {
      $(this).removeClass('dropdown--active');

      if ($(this).find('span').hasClass('icon-down-arrow')) {
        $(this).find('span').removeClass('icon-down-arrow').addClass('icon-right-arrow');
        $(this).find('.megaMenu-sub-submenu').stop().slideToggle();
      }

      const $detailsEl = $(this).find('[data-nav-details]').first();

      if ($detailsEl) {
        $detailsEl.each((_, $details) => {
          $details.open = false;
        });
      }
    });
  },
  unload: function ($target) {
    $('a[href^="#"]').off('click');
    $('[data-nav-details]').off('click');
    $('[data-nav-details]').off('touchend');
    $('#menu [aria-haspopup]').off('mouseenter');
    $('#menu [aria-haspopup]').off('mouseleave');
  }
};
/*============================================================================
  FAQ
==============================================================================*/

window.faqAccordion = {
  init: function () {
    var flg = 0;
    var $faqHeading = $('.faq__accordion > dt > button');
    $('.faq__accordion > dd').attr('aria-hidden', true);
    $faqHeading.attr('aria-expanded', false);
    $faqHeading.on('click activate', function () {
      if (flg) return false;
      flg = 1;
      var state = $(this).attr('aria-expanded') === 'false' ? true : false;
      $(this).attr('aria-expanded', state);
      $(this).parent().next().slideToggle(function () {
        flg = 0;
      });
      $(this).parent().next().attr('aria-hidden', !state);
      return false;
    });
    $faqHeading.on('keydown', function (event) {
      var keyCode = event.keyCode || e.which;

      if (keyCode === 13) {
        $(this).trigger('activate');
      }
    });
  },
  unload: function ($target) {
    $('.faq__accordion > dt > button').off('click');
    $('.faq__accordion > dt > button').off('keydown');
  }
};
/*============================================================================
  Home page - slideshow
==============================================================================*/

window.slideshow = {
  init: function () {
    $('.slideshow').each(function (index, value) {
      var $homepageSlider = $(this);
      var settings = {
        slideshowSpeed: $homepageSlider.data('slideshow-speed') * 1000,
        adaptiveHeight: $homepageSlider.data('adaptive-height')
      }; //Initiate the slideshow

      if (!$homepageSlider.hasClass('flickity-enabled')) {
        var arrowShow = $homepageSlider.find('.slideshow__gallery-cell').length === 1 ? false : true;
        $homepageSlider.flickity({
          adaptiveHeight: settings.adaptiveHeight,
          wrapAround: true,
          cellAlign: 'left',
          imagesLoaded: true,
          prevNextButtons: arrowShow,
          draggable: true,
          pageDots: arrowShow,
          autoPlay: settings.slideshowSpeed
        }); // Ensures Flickity is not collapsed when loaded

        setTimeout(function () {
          $homepageSlider.flickity('resize');
        }, 500);
        $(window).on('load', function () {
          $homepageSlider.flickity('resize');
        });
      }
    });
  },
  unload: function ($target) {
    var $slider = $target.find('.slideshow');
    $slider.flickity('destroy');
  }
};
/*============================================================================
  Home page - video
==============================================================================*/

window.video = {
  init: function () {
    // Set up plyr for newly embedded video
    var featuredVideos = $('[data-video-element]').get();
    var featuredVideoPlayers = Plyr.setup(featuredVideos, {
      controls: controls,
      fullscreen: {
        enabled: true,
        fallback: true,
        iosNative: true
      },
      storage: {
        enabled: false
      }
    }); // Adds plyr video id to video wrapper

    $.each(featuredVideoPlayers, function (index, player) {
      var id = player.id;
      var $video;

      if (player.isHTML5) {
        $video = $(player.elements.wrapper).find('video');
        $video.attr('data-plyr-video-id', id);
      } // When a video is playing, pause any other instances


      player.on('play', function (event) {
        var instance = event.detail.plyr;
        $.each(featuredVideoPlayers, function (index, player) {
          if (instance.id != player.id) {
            player.pause();
          }
        });
      });
    });
    $('[data-video-element]').each(function (index, video) {
      // Variables
      var $video = $(video);
      var $section = $video.parents('.shopify-section').attr('id', id);
      var $videoElement = $section.find($video);
      var $videoWrapper = $videoElement.parents('.video-wrapper');
      var $playButton = $videoWrapper.find('[data-play-button]');
      var $videoText = $videoWrapper.find('[data-video-text]');
      var $videoTextContainer = $videoWrapper.find('[data-video-text-container]');
      var $image = $videoWrapper.find('.video-wrapper__image');
      var $posterImage = $videoWrapper.data('poster-image-uploaded');
      var aspectRatio = $videoWrapper.data('aspect-ratio');
      var id = $videoWrapper.data('video-src');
      var isAutoplay = $videoWrapper.data('autoplay');
      var isLoopingEnabled = $videoWrapper.data('autoloop');
      var isMuted = $videoWrapper.data('mute-video');
      $.each(featuredVideoPlayers, function (index, player) {
        var videoID;
        var playerID;

        if (player.isYouTube || player.isVimeo) {
          var videoID = $videoWrapper.attr('id');
          var playerID = $(player.elements.original).attr('id');
        } else if (player.isHTML5) {
          var videoID = $videoWrapper.find('[data-plyr-video-id]').data('plyr-video-id');
          var playerID = player.id;
          $videoElement = $section.find('.plyr--video');
        }

        if (playerID == videoID) {
          // Reset play button icon
          $videoWrapper.removeClass('play-button-icon--visible'); // Autoplay

          if (isAutoplay) {
            // If on desktop or player is YouTube/Vimeo
            if (window.PXUTheme.media_queries.large.matches || player.isYouTube || player.isVimeo) {
              player.autoplay = true; // Hide image

              $image.hide(); // Show video

              $videoElement.show(); // If display text over video unchecked

              if ($videoTextContainer.hasClass('display-text-over-video--false')) {
                $videoText.hide();
              } else {
                $videoText.show();
              } // Keep play button hidden


              $playButton.hide(); // HTML5 Mobile Video
            } else if (window.PXUTheme.media_queries.medium.matches && player.isHTML5) {
              // Hide image
              $image.hide(); // Show video

              $videoElement.show(); // Display button so that video can be played

              $playButton.show();
              player.on('play', function () {
                // Show video
                $videoElement.show(); // Hide play button

                $playButton.hide();
              });
            }
          } else {
            // If Autoplay disabled
            // If poster image, show image wrapper otherwise hide it
            if ($posterImage) {
              $image.show();
              $videoElement.hide();
            } else {
              $image.hide();
              $videoElement.show();
            }
          } // Clicking image will play video


          $image.on('click', function () {
            // Hide image
            $(this).hide(); // Show video

            $videoElement.show();
            player.play();
          }); // Muted

          if (isMuted) {
            player.muted = true;
          } // Aspect Ratio


          if (aspectRatio) {
            player.ratio = aspectRatio;
          } // Looping


          if (isLoopingEnabled) {
            player.loop = true;
          } // Show Video Controls
          // - video controls get hidden using a css class: '.video-controls-enabled--false'
          // If button exists, hide text and poster


          if ($playButton) {
            $playButton.on('click', function () {
              // Hide image
              $image.hide(); // Show video

              $videoElement.show(); // If display text over video unchecked

              if ($videoTextContainer.hasClass('display-text-over-video--false')) {
                $videoText.hide();
              } else {
                $videoText.show();
              } // Play video


              player.play();
            });
          }

          player.on('play', function () {
            // Hide image
            $image.hide(); // Reset play button icon

            $videoWrapper.removeClass('play-button-icon--visible'); // Show video

            $videoElement.show(); // If display text over video unchecked

            if ($videoTextContainer.hasClass('display-text-over-video--false')) {
              $videoText.hide();
            } else {
              $videoText.show();
              $videoTextContainer.show();
            } // Hide play button


            if ($playButton) {
              $playButton.hide();
            }
          }); // If video is paused, play button icon or button must be shown
          // If button text is filled out, use play button
          // If button text is not filled out, use play button icon

          player.on('pause', function () {
            if ($playButton.length > 0) {
              $playButton.show();
              $videoWrapper.removeClass('play-button-icon--visible');
              $videoTextContainer.hide();
            } else {
              $videoWrapper.addClass('play-button-icon--visible');
            }
          }); // If page loads with video paused and no button showing, show icon

          if (!player.playing && $playButton.is(':hidden') || $playButton.length == 0) {
            $videoWrapper.addClass('play-button-icon--visible');
          }

          return false;
        }
      });
    });
  }
};
/*============================================================================
  Newsletter
==============================================================================*/

var newsletter_popup = {
  init: function () {
    var popup = Cookies.get('popup');
    var newsletter_popup_days = parseInt(window.PXUTheme.theme_settings.newsletter_popup_days);
    var cookie_enabled = newsletter_popup_days != 0 ? true : false;

    if (cookie_enabled && popup == 'open') {
      return false;
    } else {
      newsletter_popup.open();
    }

    if (cookie_enabled) {
      Cookies.set('popup', 'open', {
        expires: newsletter_popup_days
      });
    }
  },
  open: function () {
    var newsletter_popup_seconds = parseInt(window.PXUTheme.theme_settings.newsletter_popup_seconds);

    if (window.PXUTheme.theme_settings.newsletter_popup_mobile || window.PXUTheme.media_queries.large.matches) {
      setTimeout(function () {
        $.fancybox.open($('.js-newsletter-popup'), {
          baseClass: 'newsletter_popup',
          hash: false,
          infobar: false,
          toolbar: false,
          loop: true,
          smallBtn: true,
          touch: false,
          mobile: {
            preventCaptionOverlap: false,
            toolbar: true,
            buttons: ["close"]
          }
        });
      }, newsletter_popup_seconds * 1000);
    }
  }
};
/*============================================================================
  Faceted Filtering
==============================================================================*/

var facetedFiltering = {
  init: function () {
    let filterRange = document.querySelectorAll('[data-filter-range]');
    let filterCheckboxes = document.querySelectorAll('[data-filter-input]');
    let rangeNames = [];
    filterCheckboxes.forEach(function (checkbox) {
      $(checkbox).on('click', function (e) {
        e.stopPropagation();
        e.preventDefault();
        const target = e.currentTarget;
        if (target.hasAttribute('data-disabled')) return;
        window.location = target.dataset.url;
      });
    });
    $('[data-filter-modal-open]').on('click', function (e) {
      e.preventDefault();
      $.fancybox.open($('[data-filter-modal]'), {
        baseClass: 'faceted-filter-modal',
        hash: false,
        infobar: false,
        toolbar: false,
        loop: true,
        smallBtn: true,
        touch: false,
        mobile: {
          preventCaptionOverlap: false,
          toolbar: true,
          buttons: ["close"]
        },
        afterShow: function () {
          $(document.documentElement).addClass('scroll-locked');
        },
        afterClose: function () {
          $(document.documentElement).removeClass('scroll-locked');
        }
      });
    });
    $(window).on('resize.filtering', function (e) {
      if (window.innerWidth >= 768) {
        $('[data-filter-modal]').removeAttr('style');
      }
    });
    /* For range input */

    filterRange.forEach(function (filter) {
      rangeNames.push(filter.name);
    });
    $('[data-range-filter-button]').on('click', function (e) {
      e.preventDefault();
      facetedFiltering.getFilteredResults(rangeNames);
    });
  },
  getFilteredResults: function (rangeNames) {
    let searchParameters;
    const currentSearch = window.location.search.replace('?', '');
    const formData = new FormData(document.querySelector('[data-price-range-form]'));
    const newSearch = new URLSearchParams(formData).toString(); // Filter through current search string to see if price range input already exists,
    // if it does, create new string without current price range parameters

    const splitCurrentSearch = currentSearch.split('&');
    let filteredCurrentSearch = splitCurrentSearch.filter(search => {
      if (search.includes(rangeNames[0]) || search.includes(rangeNames[1])) {
        return false;
      }

      return true;
    });
    filteredCurrentSearch = filteredCurrentSearch.join('&'); // If current search parameters exist, append new search parameters
    // on to existing parameters

    if (filteredCurrentSearch.length > 0) {
      searchParameters = `${filteredCurrentSearch}&${newSearch}`;
    } else {
      searchParameters = `${newSearch}`;
    }

    let urlQueryString = '';

    if (searchParameters) {
      urlQueryString = `?${searchParameters}`;
    } else if (searchParameters) {
      urlQueryString = `?${searchParameters}`;
    }

    window.location.search = urlQueryString;
  }
};
/*============================================================================
  Predictive search
==============================================================================*/

var predictiveSearch = {
  init: function () {
    this.events = new _pixelunion_events__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z();
    this.closeSearch = document.querySelector('[data-search-close]');
    this.siteOverlay = document.querySelector('[data-site-overlay]');
    this.siteOverlayAnimation = (0,_pixelunion_animations__WEBPACK_IMPORTED_MODULE_9__/* .transition */ .eR)({
      el: this.siteOverlay
    });
    this.searchForms = document.querySelectorAll('[data-predictive-search-enabled-true]');
    this.searchForms.forEach(form => {
      const input = form.querySelector('[data-search-input]');
      const results = form.querySelector('[data-search-results]');
      const resultsContainer = form.querySelector('[data-search-results-container]');
      const animation = (0,_pixelunion_animations__WEBPACK_IMPORTED_MODULE_9__/* .transition */ .eR)({
        el: resultsContainer
      });
      this.events.register(form, 'submit', e => this._onSubmit(e, input));
      this.events.register(window, 'resize', just_debounce__WEBPACK_IMPORTED_MODULE_2___default()(() => this._onResize(resultsContainer), 250));
      this.events.register(window, 'keyup', e => this._onKeyUp(e, form, input, animation));
      this.events.register(this.closeSearch, 'click', () => this._close(form, animation));
      this.events.register(input, 'focus', () => this._onFocus(form, input, results, resultsContainer, animation));
      this.events.register(input, 'input', just_debounce__WEBPACK_IMPORTED_MODULE_2___default()(() => this._onChange(form, input, results, resultsContainer, animation), 250));
      this.events.register(document.body, 'click', e => {
        if (form.classList.contains('search-form--active')) {
          if (!form.contains(e.target)) {
            this._close(form, animation);
          }
        }
      });
    });
  },

  _onSubmit(e, input) {
    // Prevent empty form submissions
    if (this._getQuery(input).length === 0) e.preventDefault();
  },

  _onResize(resultsContainer) {
    this._resizeSearchResults(resultsContainer);
  },

  _onKeyUp(e, form, input, animation) {
    if (e.code === 'Escape') {
      input.value = '';

      this._close(form, animation);
    }
  },

  _onBlur(form, animation) {
    this._close(form, animation);
  },

  _onFocus(form, input, results, resultsContainer, animation) {
    const term = this._getQuery(input);

    if (term.length === 0) return;

    this._getSearchResults(term, form, results, resultsContainer, animation);

    this._open(form, resultsContainer, animation);
  },

  _onChange(form, input, results, resultsContainer, animation) {
    const term = this._getQuery(input);

    if (term.length === 0) {
      this._close(form, animation);

      return;
    }

    this._getSearchResults(term, form, results, resultsContainer, animation);

    this._open(form, resultsContainer, animation);
  },

  _getQuery(input) {
    return input.value.trim();
  },

  _open(form, resultsContainer, animation) {
    animation.animateTo('open').then(() => {
      document.body.classList.add('scroll-locked');
      form.classList.add('search-form--active');

      if (form.classList.contains('search-form--overlay-enabled-true')) {
        this.siteOverlayAnimation.animateTo('open');
      }

      if (form.closest('.top-bar') && window.PXUTheme.media_queries.medium.matches) {
        this.closeSearch.style.display = 'flex';
      }

      this._resizeSearchResults(resultsContainer);
    });
  },

  _close(form, animation) {
    animation.animateTo('closed').then(() => {
      form.classList.remove('search-form--active');
      document.body.classList.remove('scroll-locked');

      if (form.classList.contains('search-form--overlay-enabled-true')) {
        this.siteOverlayAnimation.animateTo('closed');
      }

      if (window.PXUTheme.media_queries.medium.matches) {
        this.closeSearch.style.display = 'none';
      }
    });
  },

  _getSearchResults(term, form, results, resultsContainer, animation) {
    const resourceType = form.classList.contains('search-form--blog') ? '&resources[type]=article' : '';
    resultsContainer.setAttribute('data-loading', 'true');
    fetch(`${window.PXUTheme.routes.predictive_search_url}?q=${term}${resourceType}&section_id=predictive-search`).then(response => {
      if (!response.ok) {
        const error = new Error(response.status);
        throw error;
      }

      return response.text();
    }).then(text => {
      const resultsMarkup = new DOMParser().parseFromString(text, 'text/html').querySelector('#shopify-section-predictive-search').innerHTML;

      this._renderSearchResults(resultsMarkup, form, results, resultsContainer, animation);
    }).catch(error => {
      throw error;
    });
  },

  _renderSearchResults(resultsMarkup, form, results, resultsContainer, animation) {
    resultsContainer.setAttribute('data-loading', 'false');
    results.innerHTML = resultsMarkup;

    this._registerEvents(form, animation);
  },

  _registerEvents(form, animation) {
    this.searchButton = form.querySelector('[data-predictive-search-button]');
    this.events.register(this.searchButton, 'blur', () => this._onBlur(form, animation));
  },

  _resizeSearchResults(resultsContainer) {
    const offset = 30;
    const position = resultsContainer.parentNode.getBoundingClientRect();
    const maxHeight = window.innerHeight - position.bottom - offset;
    resultsContainer.style.setProperty('--search-results-max-height', `${maxHeight}px`);
  }

};
/*============================================================================
  Product
==============================================================================*/

window.product = {
  init: function () {
    var $notify_form = $('.notify_form .contact-form'); // Find product galleries on page but exclude those in the quickshop (quickshop logic handled in fancybox event)

    var $productGalleries = $('div:not(.fancybox-content) .product-gallery'); // For each product gallery, create an object and add it to an array of galleries

    var galleriesArray = [];
    globalPlayersArray = [];

    if ($productGalleries.length > 0) {
      $.each($productGalleries, function (index, gallery) {
        var $productSection = $(gallery).closest('.product_section');
        galleriesArray.push({
          element: $(gallery),
          productSection: $productSection,
          thumbnailsEnabled: $productSection.data('thumbnails-enabled'),
          thumbnailsSliderEnabled: $productSection.data('thumbnails-slider-enabled'),
          thumbnailsPosition: $productSection.data('thumbnails-position'),
          thumbnailsArrows: $productSection.data('gallery-arrows-enabled'),
          slideshowAnimation: $productSection.data('slideshow-animation'),
          slideShowSpeed: $productSection.data('slideshow-speed'),
          activateZoom: $productSection.data('activate-zoom'),
          productMediaSupported: $productSection.data('product-media-supported'),
          loopingEnabled: $(gallery).find('.product-gallery__main').data('video-looping-enabled'),
          sectionID: $productSection.parents('.shopify-section').attr('id')
        });
      });
    }

    if (galleriesArray.length > 0) {
      // For each galleryObject, enable a Flickity slider
      $.each(galleriesArray, function (index, galleryObject) {
        window.product.enableSlider(galleryObject); // If product media is supported for the gallery, then also launch product media and Plyr

        if (galleryObject.productMediaSupported) {
          // Find videos within gallery section
          var videos;
          videos = $(galleryObject.element).find('[data-html5-video] video, [data-youtube-video]').get();
          window.product.loadPlyr(galleryObject, videos);
          window.product.launchProductMedia(galleryObject); // Go through each gallery, on video play, check instance ID against other player IDs

          var instance;
          $.each(galleryObject.videoPlayers, function (index, player) {
            player.on('play', function (event) {
              // When video starts playing grab id of instance
              instance = event.detail.plyr;
              $.each(globalPlayersArray, function (index, player) {
                if (instance.id != player.id) {
                  player.pause();
                }
              });
            });
          });
        } // Hover to zoom


        if (galleryObject.activateZoom) {
          document.addEventListener('lazybeforeunveil', window.product.enableZoom);
        }
      });
    }

    if ($('.product-recommendations').length) {
      this.loadProductRecommendations();
    }

    const $defaultSelector = $('.js-product_section [data-product-form]:not(.product-recommendations .js-product_section [data-product-form])');
    $defaultSelector.each((_, options) => {
      const $options = $(options);
      const productTitle = $options.data('product-title');
      const productDetailsEl = options.closest('[data-product-details]');
      const surfacePickUpEl = productDetailsEl.querySelector('[data-surface-pick-up]');
      const paymentTerms = new _helpers_PaymentTerms__WEBPACK_IMPORTED_MODULE_10__/* .default */ .Z(productDetailsEl);
      let currentVariantId = $options.data('variant-id');
      let currentVariantTitle = $options.data('variant-title');
      let surfacePickUp;

      if (surfacePickUpEl) {
        surfacePickUp = new _pixelunion_shopify_surface_pick_up__WEBPACK_IMPORTED_MODULE_11__/* .default */ .Z(surfacePickUpEl);
        surfacePickUp.load(currentVariantId);
        surfacePickUp.onModalRequest(contents => {
          const surfacePickUpModal = document.querySelector('[data-surface-pick-up-modal]');
          let fragment; // Build out pop-up content for product with no variants, else build
          // out popup content for product with variants

          if (currentVariantTitle == 'Default Title' && productTitle) {
            fragment = document.createDocumentFragment();
            const header = document.createElement('div');
            const title = document.createElement('h2');
            header.classList.add('surface-pick-up__modal-header');
            title.classList.add('surface-pick-up__modal-title');
            title.innerHTML = productTitle;
            header.appendChild(title);
            fragment.appendChild(header);
          } else if (currentVariantTitle !== 'Default Title' && productTitle) {
            fragment = document.createDocumentFragment();
            const header = document.createElement('div');
            const title = document.createElement('h2');
            header.classList.add('surface-pick-up__modal-header');
            title.classList.add('surface-pick-up__modal-title');
            title.innerHTML = productTitle;
            header.appendChild(title);

            if (window.currentVariant.title !== 'Default Title') {
              const subtitle = document.createElement('span');
              subtitle.classList.add('surface-pick-up__modal-subtitle');
              subtitle.innerHTML = window.currentVariant.title;
              header.appendChild(subtitle);
            }

            fragment.appendChild(header);
          }

          surfacePickUpModal.innerHTML = contents;
          surfacePickUpModal.insertBefore(fragment, surfacePickUpModal.firstChild);
          $.fancybox.open(surfacePickUpModal, {
            hash: false,
            infobar: false,
            toolbar: false,
            loop: true,
            smallBtn: true,
            touch: false,
            video: {
              autoStart: false
            },
            mobile: {
              preventCaptionOverlap: false,
              toolbar: true
            }
          });
        });
      }

      const selectId = $options.data("select-id");

      if (document.getElementById(selectId)) {
        new Shopify.OptionSelectors($options.data('select-id'), {
          product: $options.data('product'),
          onVariantSelected: (variant, selector) => {
            window.currentVariant = variant;
            paymentTerms.update(variant ? variant.id : null);

            if (surfacePickUp) {
              surfacePickUp.load(variant ? variant.id : null);
            }

            window.selectCallback(variant, selector);
          },
          enableHistoryState: $options.data('enable-state')
        });
      }
    });
    $('.product_form').addClass('is-visible');

    if (window.PXUTheme.theme_settings.product_form_style == "swatches") {
      $('.swatch :radio').change(function () {
        var optionIndex = $(this).closest('.swatch').attr('data-option-index');
        var optionValue = $(this).val();
        $(this).closest('form').find('.single-option-selector').eq(optionIndex).val(optionValue).trigger('change');
      }); //Swatches linked with selected options

      if ($('.js-product_section').length) {
        var $productForms = $('.js-product_section').find('.product_form'); //Loop through each product and set the initial option value state

        $productForms.each(function () {
          var JSONData = $(this).data('product');
          var productID = $(this).data('product-id');
          var productSection = '.product-' + productID + ' .js-product_section';
          var swatchOptions = $(this).find('.swatch_options .swatch');

          if (swatchOptions.length > 1) {
            Shopify.linkOptionSelectors(JSONData, productSection);
          }
        });
      } //Add click event when there is more than one product on the page (eg. Collection in Detail)


      if ($('.js-product_section').length > 1) {
        $('body').on('click', '.swatch-element', function () {
          var swatchValue = $(this).data('value').toString();
          $(this).siblings('input[value="' + swatchValue.replace(/\"/g, '\\"') + '"]').prop("checked", true).trigger("change");
          var JSONData = $(this).parents('.product_form').data('product');
          var productID = $(this).parents('.product_form').data('product-id');
          var productSection = '.product-' + productID + ' .js-product_section';
          var swatchOptions = $(this).parents('.product_form').find('.swatch_options .swatch');

          if (swatchOptions.length > 1) {
            Shopify.linkOptionSelectors(JSONData, productSection);
          }
        });
      }
    }

    const recipientFormEl = document.querySelector('[data-recipient-form]');

    if (recipientFormEl) {
      const sectionEl = recipientFormEl.closest('.product_section');
      this.recipientForm = new _helpers_RecipientForm__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z(sectionEl);
    } // Complementary products


    const complementaryProductsEl = document.querySelector('[data-complementary-products]');

    if (complementaryProductsEl) {
      const sectionEl = complementaryProductsEl.closest('.product_section');
      const {
        sectionId,
        productId,
        productRecommendationLimit
      } = JSON.parse(document.querySelector('[data-complementary-products-data]').textContent);
      this.complementaryProductRecommendations = new _helpers_ComplementaryProducts__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z({
        sectionEl,
        sectionId,
        productId,
        productRecommendationsRoute: window.PXUTheme.routes.product_recommendations_url,
        includeIndicatorDots: true,
        limit: productRecommendationLimit,
        arrowShape: 'M95.04 46 21.68 46 48.18 22.8 42.91 16.78 4.96 50 42.91 83.22 48.18 77.2 21.68 54 95.04 54 95.04 46z'
      });
    }
  },
  enableZoom: function () {
    var $image = $(event.target);
    var zoomSrc = $image.data('zoom-src');

    if (zoomSrc) {
      $image.wrap('<span class="zoom-container"></span>').css('display', 'block').parent().zoom({
        url: zoomSrc,
        touch: false,
        magnify: 1
      });
    }
  },
  enableSlider: function (galleryObject) {
    var $el = galleryObject.element.find('.product-gallery__main');
    var $thumbnailProductGallery = galleryObject.element.find('.product-gallery__thumbnails');
    var $slides = $el.find('.product-gallery__image');
    var $thumbnails = $thumbnailProductGallery.find('.product-gallery__thumbnail');
    var arrowShape = 'M95.04 46 21.68 46 48.18 22.8 42.91 16.78 4.96 50 42.91 83.22 48.18 77.2 21.68 54 95.04 54 95.04 46z';
    $el.flickity({
      wrapAround: true,
      adaptiveHeight: true,
      dragThreshold: 10,
      imagesLoaded: true,
      pageDots: false,
      prevNextButtons: $el.data('media-count') > 1 ? true : false,
      autoPlay: galleryObject.slideShowSpeed * 1000,
      fade: galleryObject.slideShowAnimation === 'fade' ? true : false,
      watchCSS: false,
      arrowShape: arrowShape
    });
    var $slides = $el.find('.product-gallery__image');
    $slides.each((_, slide) => {
      const $slide = $(slide); // Listen for model pause/play events

      $slide.find('model-viewer').on('shopify_model_viewer_ui_toggle_play', function () {
        $el.flickity('unbindDrag');
      });
      $slide.find('model-viewer').on('shopify_model_viewer_ui_toggle_pause', function () {
        $el.flickity('bindDrag');
      });
    });
    $el.on('change.flickity', function () {
      $slides.each(function (index, slide) {
        // Variables to be used
        var $slide = $(slide);
        var mediaType = $slide.data('media-type'); // Check whether slide is active slide (featured image shown) or inactive slide (slide hidden)

        if ($slide.hasClass('is-selected')) {
          // Switch statement to go through different media types (video, model)
          switch (mediaType) {
            case 'model':
              /* On slide change, if active slide contains 3d model
              * If on desktop, on hover, unbind flickity, after hover bind flickity
              * On model play event, unbind flickity to ensure model can be interacted with
              * On model pause event, bind flickity so that slide can be swiped
              * Pause all model slides when hidden
              */
              if (window.PXUTheme.media_queries.large.matches) {
                // On mouseenter event, unbind flickity
                $slide.on('mouseenter', function () {
                  $el.flickity('unbindDrag');
                }); // On mouseleave event, bind flickity

                $slide.on('mouseleave', function () {
                  $el.flickity('bindDrag');
                });
              }

              break;
          }
        } else {
          // Below logic deals with the hidden slides when a flickity change is triggered
          // Switch statement to go through different media types (video, model)
          switch (mediaType) {
            case 'model':
              // Pause models when hidden
              if (galleryObject.models.length > 0) {
                $.each(galleryObject.models, function (index, model) {
                  model.pause();
                });
              }

              break;

            case 'video':
              // Variables
              var $htmlVideo = $slide.find('[data-html5-video]');
              var videoID = $htmlVideo.find('video').data('plyr-video-id'); // Pause all html5 videos for slides that are hidden

              if ($htmlVideo.length) {
                $.each(galleryObject.videoPlayers, function (index, player) {
                  if (player.id == videoID) {
                    player.pause();
                  }
                });
              }

              break;

            case 'external_video':
              // Variables
              var $iframeVideo = $slide.find('iframe');
              var iframeID = $iframeVideo.attr('id'); // Pause all youtube videos for slides that are hidden

              if ($iframeVideo.length) {
                $.each(galleryObject.videoPlayers, function (index, player) {
                  if (player.media.id == iframeID) {
                    player.pause();
                  }
                });
              }

              break;
          }
        }
      });
    });
    $el.on('ready.flickity', function () {
      // Allow timing for external video loading
      setTimeout(function () {
        $el.flickity('resize');
      }, 250);
    });
    $el.on('settle.flickity', function () {
      $el.flickity('resize');
    });
    window.addEventListener('load', function () {
      $el.flickity('resize');
    }); // Checks for 3D Models and takes care of binding/unbinding slider

    $slides.each(function (index, slide) {
      // Variables to be used
      var $slide = $(slide);
      var mediaType = $slide.data('media-type'); // Check whether slide is active slide (featured image shown)

      if ($slide.hasClass('is-selected')) {
        if (mediaType == 'model') {
          // If slide has 3D model, unbind flickity on hover on desktop
          // Allows you to click anywhere to trigger model ui
          if (window.PXUTheme.media_queries.large.matches) {
            // On mouseenter event, unbind flickity
            $slide.on('mouseenter', function () {
              $el.flickity('unbindDrag');
            }); // On mouseleave event, bind flickity

            $slide.on('mouseleave', function () {
              $el.flickity('bindDrag');
            });
          } // Detect keyboard 'ENTER' key on slides


          $slide.keypress(function (event) {
            if (event.which == 13) {
              $slide.find('model-viewer, .product-gallery__link, .plyr').focus();
              $el.on('settle.flickity', function (event, index) {
                // Run video autoplay logic if featured media is a video
                if (mediaType == 'video' || mediaType == 'external_video') {
                  checkForVideos();
                } // Autoplay model if featured media is a model


                if (mediaType == 'model') {
                  // If model container has class is-selected then play the model
                  autoplayModel();
                } // Unbind settle event


                $el.off('settle.flickity');
              });
            }
          });
        }
      }
    });
    var $sliderArrows = $el.find('.flickity-prev-next-button');

    if (($sliderArrows || $thumbnails) && window.PXUTheme.media_queries.large.matches) {
      $sliderArrows.on('click', function () {
        // Find out media type of featured media slide
        var mediaType = $el.find('.product-gallery__image.is-selected').data('media-type');
        $el.on('settle.flickity', function (event, index) {
          // Run video autoplay logic if featured media is a video
          if (mediaType == 'video' || mediaType == 'external_video') {
            checkForVideos();
          } // Autoplay model if featured media is a model


          if (mediaType == 'model') {
            // If model container has class is-selected then play the model
            autoplayModel();
          } // Unbind settle event


          $el.off('settle.flickity');
        });
      }); // Detect keyboard 'ENTER' key on slider arrows

      $sliderArrows.on('keypress', function (event) {
        if (event.which == 13) {
          $el.focus();
          $el.attr('tabindex', 0);
          $el.find('.product-gallery__image').attr('tabindex', -1);
        }
      });
      $thumbnails.on('click', function () {
        // Change slide
        var index = $(event.currentTarget).index();
        $el.flickity('select', index); // Find out media type of featured media slide

        var mediaType = $el.find('.product-gallery__image.is-selected').data('media-type');
        $el.on('settle.flickity', function (event, index) {
          // Run video autoplay logic if featured media is a video
          if (mediaType == 'video' || mediaType == 'external_video') {
            checkForVideos();
          } // Autoplay model if featured media is a model


          if (mediaType == 'model') {
            // If model container has class is-selected then play the model
            autoplayModel();
          } // Unbind settle event


          $el.off('settle.flickity');
        });
      }); // Added functionality for keyboard 'enter' key

      $thumbnails.keypress(function (event) {
        var index = $(event.currentTarget).index();

        if (event.which == 13) {
          // Change slide
          $el.flickity('select', index); // Find selected slide

          var $selectedSlide = $el.find('.product-gallery__image.is-selected'); // Find out media type of featured media slide

          var mediaType = $selectedSlide.data('media-type'); // Bring focus to media inside selected slide once slide has finished animation

          $el.on('settle.flickity', function (event, index) {
            $selectedSlide.find('[data-youtube-video]').attr('tabindex', '0');
            $selectedSlide.find('model-viewer, .plyr, .product-gallery__link').focus(); // Run video autoplay logic if featured media is a video

            if (mediaType == 'video' || mediaType == 'external_video') {
              checkForVideos();
            } // Autoplay model if featured media is a model


            if (mediaType == 'model') {
              // If model container has class is-selected then play the model
              autoplayModel();
            } // Unbind settle event


            $el.off('settle.flickity');
          });
        }
      });
    }

    function autoplayModel() {
      $.each(galleryObject.models, function (index, model) {
        var $slide = $(model.container).parents('.product-gallery__image');

        if ($slide.hasClass('is-selected')) {
          model.play();
        }
      });
    }

    function checkForVideos() {
      $slides.each(function (index, slide) {
        // Variables
        var $slide = $(slide);
        var mediaType = $slide.data('media-type');
        var videoID = $slide.find('video').data('plyr-video-id');
        var $iframeVideo = $slide.find('iframe');
        var iframeID = $iframeVideo.attr('id');

        if ($slide.hasClass('is-selected')) {
          if (mediaType == 'video') {
            videoID = $slide.find('video').data('plyr-video-id');

            if (videoID) {
              autoplayVideo(videoID, $slide);
            }
          } else if (mediaType == 'external_video') {
            if (iframeID) {
              autoplayYoutubeVideo(iframeID, $slide);
            }
          }
        }
      });
    }

    function autoplayVideo(videoID, $slide) {
      // Compare id to player object and only play that video
      $.each(galleryObject.videoPlayers, function (index, player) {
        if (player.id == videoID) {
          player.play(); // On fullscreen exit, focus on the thumbnail nav

          player.on('exitfullscreen', function (event) {
            var $thumbnailProductGallery = $slide.closest('.product-gallery').find('.product-gallery__thumbnails');

            if ($thumbnailProductGallery.hasClass('vertical-slider-enabled')) {
              $thumbnailProductGallery.attr('tabindex', '0').focus();
            } else {
              $thumbnailProductGallery.focus();
            }
          });
        }
      });
    }

    function autoplayYoutubeVideo(iframeID, $slide) {
      // compare id to player object and only play that video
      $.each(galleryObject.videoPlayers, function (index, player) {
        if (player.playing) {
          player.pause();
        }

        if (player.media.id == iframeID) {
          player.play(); // On fullscreen exit, focus on the thumbnail nav

          player.on('exitfullscreen', function (event) {
            var $thumbnailProductGallery = $slide.closest('.product-gallery').find('.product-gallery__thumbnails');

            if ($thumbnailProductGallery.hasClass('vertical-slider-enabled')) {
              $thumbnailProductGallery.attr('tabindex', '0').focus();
            } else {
              $thumbnailProductGallery.focus();
            }
          });
        }
      });
    } // Thumbnail gallery logic begins


    if (galleryObject.thumbnailsEnabled == true) {
      if (galleryObject.thumbnailsSliderEnabled == true && $slides.length > 1) {
        // If desktop determine which slider we build
        if (window.PXUTheme.media_queries.large.matches) {
          // If thumbnail position is left/right then vertical slider gets enabled
          if (galleryObject.thumbnailsPosition == 'left-thumbnails' || galleryObject.thumbnailsPosition == 'right-thumbnails') {
            $thumbnailProductGallery.css('max-height', $el.closest('.product-gallery').outerHeight());
            $thumbnailProductGallery.addClass('vertical-slider-enabled');
            $thumbnails.on('click', function (event) {
              var index = $(event.currentTarget).index();
              $el.flickity('select', index);
            });
            var navCellHeight = $thumbnails.height();
            var navHeight = $thumbnailProductGallery.height();
            $el.on('select.flickity', function () {
              // set selected nav cell
              var flkty = $el.data('flickity');
              $thumbnailProductGallery.find('.is-nav-selected').removeClass('is-nav-selected');
              var $selected = $thumbnails.eq(flkty.selectedIndex).addClass('is-nav-selected'); // scroll nav

              var scrollY = $selected.position().top + $thumbnailProductGallery.scrollTop() - (navHeight + navCellHeight) / 2;
              $thumbnailProductGallery.animate({
                scrollTop: scrollY
              });
            });
          } else {
            $thumbnailProductGallery.flickity({
              cellAlign: 'center',
              contain: true,
              groupCells: '80%',
              imagesLoaded: true,
              pageDots: false,
              prevNextButtons: $thumbnails.length > 5 ? galleryObject.thumbnailsArrows : false,
              asNavFor: $el[0],
              arrowShape: arrowShape
            }); // Ensures Flickity is not collapsed when loaded

            setTimeout(function () {
              $thumbnailProductGallery.flickity('resize');
            }, 500);
            $(window).on('load', function () {
              $thumbnailProductGallery.flickity('resize');
            }); // Once thumbnail is focused, move carousel to that cell

            $.each($thumbnails, function (index, thumbnail) {
              var $thumbnail = $(thumbnail);

              if ($thumbnail.hasClass('is-selected')) {
                $thumbnail.on('focus', function () {
                  $thumbnailProductGallery.flickity('selectCell', index);
                });
              }
            });
          }
        } else {
          // If not on desktop, create standard thumbnail slider
          $thumbnailProductGallery.flickity({
            cellAlign: 'center',
            contain: true,
            groupCells: '80%',
            imagesLoaded: true,
            pageDots: false,
            prevNextButtons: $thumbnails.length > 5 ? galleryObject.thumbnailsArrows : false,
            asNavFor: $el[0],
            arrowShape: arrowShape
          });
        }
      } else {
        // If thumbnail slider is disabled, ensure thumbnails can still navigate product images
        $thumbnailProductGallery.find('.product-gallery__thumbnail').on('click', function () {
          var index = $(this).index();
          $el.flickity('selectCell', index);
        });
      }
    }
  },
  launchProductMedia: function (galleryObject) {
    // function to check if browser is IE
    var isIE11 = !!navigator.userAgent.match(/Trident.*rv\:11\./); // Ensure product media libraries are present

    if (!isIE11) {
      window.Shopify.loadFeatures([{
        name: 'shopify-xr',
        version: '1.0'
      }, {
        name: 'model-viewer-ui',
        version: '1.0'
      }], onAllFeaturesLoaded);
    } // Enable looping for videos based off their section setting
    // Find videos where they are contained within this section
    // Set looping


    $.each(galleryObject.videoPlayers, function (index, player) {
      var $wrapper = $(player.elements.wrapper);

      if (galleryObject.sectionID != null) {
        var $section = $wrapper.parents('.shopify-section').attr('id', galleryObject.sectionID);
        var loopingEnabled = $section.find(galleryObject.element).find('.product-gallery__main').data('video-looping-enabled');
      } else {
        var loopingEnabled = galleryObject.element.find('.product-gallery__main').data('video-looping-enabled');
      }

      player.loop = loopingEnabled;
    }); // 3D Model Setup

    var config = {
      // Default control list
      controls: ['zoom-in', 'zoom-out', 'fullscreen'],
      focusOnPlay: false
    };

    function onAllFeaturesLoaded() {
      // If product media enabled look for model-viewer tags and setup
      galleryObject.models = [];
      var $models = $($('model-viewer', galleryObject.element));
      $models.each(function (index, model) {
        model = new Shopify.ModelViewerUI(model, config);
        galleryObject.models.push(model);
      });
    }
  },
  enableVideoOnHover: function ($thumbnail) {
    var $html5Video = $thumbnail.find('[data-html5-video]');
    var $youtubeVideo = $thumbnail.find('[data-youtube-video]');
    var videoID;

    if ($html5Video.length > 0) {
      videoID = $html5Video.find('[data-plyr-video-id]').data('plyr-video-id');
    } else if ($youtubeVideo.length > 0) {
      videoID = $youtubeVideo.find('iframe').attr('id');
    }

    if (videoID) {
      $.each(secondaryMediaPlayers, function (index, player) {
        if (player.id == videoID || player.media.id == videoID) {
          player.toggleControls(false);
          player.muted = true;
          player.play();
        }
      });
    }
  },
  disableVideoOnHover: function ($thumbnail) {
    var $html5Video = $thumbnail.find('[data-html5-video]');
    var $youtubeVideo = $thumbnail.find('[data-youtube-video]');
    var videoID;

    if ($html5Video.length > 0) {
      videoID = $html5Video.find('[data-plyr-video-id]').data('plyr-video-id');
    } else if ($youtubeVideo.length > 0) {
      videoID = $youtubeVideo.find('iframe').attr('id');
    }

    if (videoID) {
      $.each(secondaryMediaPlayers, function (index, player) {
        if (player.id == videoID || player.media.id == videoID) {
          if (player.playing) {
            player.pause();
          }
        }
      });
    }
  },
  loadPlyr: function (galleryObject, videos, showSecondaryMedia) {
    // Initializes Plyr library for HTML5 and YouTube videos in Product Gallery
    window.utilities.launchVideoPlayer(Plyr, galleryObject, videos, showSecondaryMedia);

    if (galleryObject) {
      // Adds plyr video id to video wrapper
      $.each(galleryObject.videoPlayers, function (index, player) {
        var source = player.provider;
        var id = player.id;
        var $video;

        if (source == 'html5') {
          $video = $(player.elements.wrapper).find('video');
          $video.attr('data-plyr-video-id', id);
        }
      });
    }
  },
  initializeQuantityBox: function () {
    $('body').on('click', '.js-change-quantity', function () {
      var $this = $(this),
          $input = $(this).siblings('input'),
          val = parseInt($input.val()),
          valMax = 100000000000000000000000000000,
          valMin = $input.attr('min') || 0;

      if ($input.attr('max') != null) {
        valMax = $input.attr('max');
      }

      if (isNaN(val) || val < valMin) {
        $input.val(valMin);
        return false;
      } else if (val > valMax) {
        $input.val(valMax);
        return false;
      }

      if ($this.data('func') == 'plus') {
        if (val < valMax) $input.val(val + 1);
      } else {
        if (val > valMin) $input.val(val - 1);

        if ($this.parents(".cart--info-wrapper").length) {
          if (val - 1 == 0) {
            $this.closest('.cart--info-wrapper').addClass('animated fadeOutUp');
          }
        }
      }

      $input.trigger('change');
    });
  },
  loadProductRecommendations: function () {
    /* NE compatibility
    * In NE, we will have a dynamic section ID that will need to be grabbed from the DOM like the other variables
    * var sectionID = $productRecommendationsContainer.data('section-id');
    Ends NE compatibility */
    var $productRecommendations = $('.product-recommendations');
    var productID = $productRecommendations.data('product-id');
    var limit = $productRecommendations.data('limit');
    var recommendationsURL = $productRecommendations.data('recommendations-url');
    var sectionEnabled = $productRecommendations.data('enabled');
    var sectionId = $productRecommendations.data('section-id');
    /* NE compatibility
    * In NE, this request url will need to be updated to reflect the dynamic section ID, 'section_id=' + sectionID
    Ends NE compatibility */
    // Build request URL

    var requestUrl = recommendationsURL + "?section_id=" + sectionId + "&limit=" + limit + "&product_id=" + productID;
    $.ajax({
      type: 'GET',
      url: requestUrl,
      success: function (data) {
        if (!sectionEnabled) {
          return;
        }

        var $recommendedProductsElement = $(data).find('.product-recommendations').html(); // Insert product list into the product recommendations container

        $productRecommendations.html($recommendedProductsElement); // Initialize shopify payment buttons

        if (Shopify.PaymentButton) {
          Shopify.PaymentButton.init();
        }

        window.collection.init();
      }
    });
  },
  unload: function ($target) {
    // Destroy Flickity slider
    var $gallerySlider = $target.find('.product-gallery__main');
    var $thumbnailSlider = $target.find('.product-gallery__thumbnails');
    $gallerySlider.flickity('destroy');
    $thumbnailSlider.flickity('destroy');
    document.removeEventListener('lazybeforeunveil', window.product.enableZoom);
    window.removeEventListener('load', function () {
      $el.flickity('resize');
    });
    $('body').off('click', '.js-change-quantity');
  }
};
/*============================================================================
  Map
==============================================================================*/

window.map = {
  init: function () {
    if ($(".shopify-section--map .map, .shopify-section--page-contact-template .map, .details-section .map, .product-details .map").hasClass('js-api-map')) {
      var mapsToLoad = []; //Create map settings array

      $('.map').each(function (i, obj) {
        mapsToLoad.push(this);
        mapsToLoad[i].sectionid = $(this).data('id');
        mapsToLoad[i].address = $(this).data('address');
        mapsToLoad[i].directions = $(this).data('directions-address');
        mapsToLoad[i].zoom = $(this).data('zoom');
        mapsToLoad[i].mapstyle = $(this).data('style');
        mapsToLoad[i].showpin = $(this).data('pin');
        mapsToLoad[i].apikey = $(this).data('api-key');
      });
      $.each(mapsToLoad, function (i, instance) {
        //Enable caching to avoid duplicate google maps files
        $.ajaxSetup({
          cache: true
        }); //Load maps script and find location coordinates

        $.getScript('https://maps.googleapis.com/maps/api/js?key=' + mapsToLoad[i].apikey).then(function () {
          window.map.findLocation(mapsToLoad[i]);
          $.ajaxSetup({
            cache: false
          });
        });
      });
    }
  },
  findLocation: function (mapArray) {
    var geoLat;
    var geoLng;
    var geocoder = new google.maps.Geocoder(); //Find and set coordinates

    geocoder.geocode({
      'address': mapArray.address
    }, function (results, status) {
      if (status == google.maps.GeocoderStatus.OK) {
        geoLat = results[0].geometry.location.lat();
        geoLng = results[0].geometry.location.lng(); //Create map

        window.map.initMap(geoLat, geoLng, mapArray);
      }
    });
  },
  initMap: function (lat, lng, mapArray) {
    var location = {
      lat: lat,
      lng: lng
    };
    var styleJson = []; //Set style JSON

    if (mapArray.mapstyle == 'aubergine') {
      styleJson = [{
        "elementType": "geometry",
        "stylers": [{
          "color": "#1d2c4d"
        }]
      }, {
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#8ec3b9"
        }]
      }, {
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#1a3646"
        }]
      }, {
        "featureType": "administrative.country",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#4b6878"
        }]
      }, {
        "featureType": "administrative.land_parcel",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#64779e"
        }]
      }, {
        "featureType": "administrative.province",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#4b6878"
        }]
      }, {
        "featureType": "landscape.man_made",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#334e87"
        }]
      }, {
        "featureType": "landscape.natural",
        "elementType": "geometry",
        "stylers": [{
          "color": "#023e58"
        }]
      }, {
        "featureType": "poi",
        "elementType": "geometry",
        "stylers": [{
          "color": "#283d6a"
        }]
      }, {
        "featureType": "poi",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#6f9ba5"
        }]
      }, {
        "featureType": "poi",
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#1d2c4d"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "geometry.fill",
        "stylers": [{
          "color": "#023e58"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#3C7680"
        }]
      }, {
        "featureType": "road",
        "elementType": "geometry",
        "stylers": [{
          "color": "#304a7d"
        }]
      }, {
        "featureType": "road",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#98a5be"
        }]
      }, {
        "featureType": "road",
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#1d2c4d"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry",
        "stylers": [{
          "color": "#2c6675"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#255763"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#b0d5ce"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#023e58"
        }]
      }, {
        "featureType": "transit",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#98a5be"
        }]
      }, {
        "featureType": "transit",
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#1d2c4d"
        }]
      }, {
        "featureType": "transit.line",
        "elementType": "geometry.fill",
        "stylers": [{
          "color": "#283d6a"
        }]
      }, {
        "featureType": "transit.station",
        "elementType": "geometry",
        "stylers": [{
          "color": "#3a4762"
        }]
      }, {
        "featureType": "water",
        "elementType": "geometry",
        "stylers": [{
          "color": "#0e1626"
        }]
      }, {
        "featureType": "water",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#4e6d70"
        }]
      }];
    } else if (mapArray.mapstyle == 'retro') {
      styleJson = [{
        "elementType": "geometry",
        "stylers": [{
          "color": "#ebe3cd"
        }]
      }, {
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#523735"
        }]
      }, {
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#f5f1e6"
        }]
      }, {
        "featureType": "administrative",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#c9b2a6"
        }]
      }, {
        "featureType": "administrative.land_parcel",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#dcd2be"
        }]
      }, {
        "featureType": "administrative.land_parcel",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#ae9e90"
        }]
      }, {
        "featureType": "landscape.natural",
        "elementType": "geometry",
        "stylers": [{
          "color": "#dfd2ae"
        }]
      }, {
        "featureType": "poi",
        "elementType": "geometry",
        "stylers": [{
          "color": "#dfd2ae"
        }]
      }, {
        "featureType": "poi",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#93817c"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "geometry.fill",
        "stylers": [{
          "color": "#a5b076"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#447530"
        }]
      }, {
        "featureType": "road",
        "elementType": "geometry",
        "stylers": [{
          "color": "#f5f1e6"
        }]
      }, {
        "featureType": "road.arterial",
        "elementType": "geometry",
        "stylers": [{
          "color": "#fdfcf8"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry",
        "stylers": [{
          "color": "#f8c967"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#e9bc62"
        }]
      }, {
        "featureType": "road.highway.controlled_access",
        "elementType": "geometry",
        "stylers": [{
          "color": "#e98d58"
        }]
      }, {
        "featureType": "road.highway.controlled_access",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#db8555"
        }]
      }, {
        "featureType": "road.local",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#806b63"
        }]
      }, {
        "featureType": "transit.line",
        "elementType": "geometry",
        "stylers": [{
          "color": "#dfd2ae"
        }]
      }, {
        "featureType": "transit.line",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#8f7d77"
        }]
      }, {
        "featureType": "transit.line",
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#ebe3cd"
        }]
      }, {
        "featureType": "transit.station",
        "elementType": "geometry",
        "stylers": [{
          "color": "#dfd2ae"
        }]
      }, {
        "featureType": "water",
        "elementType": "geometry.fill",
        "stylers": [{
          "color": "#b9d3c2"
        }]
      }, {
        "featureType": "water",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#92998d"
        }]
      }];
    } else if (mapArray.mapstyle == 'silver') {
      styleJson = [{
        "elementType": "geometry",
        "stylers": [{
          "color": "#f5f5f5"
        }]
      }, {
        "elementType": "labels.icon",
        "stylers": [{
          "visibility": "off"
        }]
      }, {
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#616161"
        }]
      }, {
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#f5f5f5"
        }]
      }, {
        "featureType": "administrative.land_parcel",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#bdbdbd"
        }]
      }, {
        "featureType": "poi",
        "elementType": "geometry",
        "stylers": [{
          "color": "#eeeeee"
        }]
      }, {
        "featureType": "poi",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#757575"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "geometry",
        "stylers": [{
          "color": "#e5e5e5"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#9e9e9e"
        }]
      }, {
        "featureType": "road",
        "elementType": "geometry",
        "stylers": [{
          "color": "#ffffff"
        }]
      }, {
        "featureType": "road.arterial",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#757575"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry",
        "stylers": [{
          "color": "#dadada"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#616161"
        }]
      }, {
        "featureType": "road.local",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#9e9e9e"
        }]
      }, {
        "featureType": "transit.line",
        "elementType": "geometry",
        "stylers": [{
          "color": "#e5e5e5"
        }]
      }, {
        "featureType": "transit.station",
        "elementType": "geometry",
        "stylers": [{
          "color": "#eeeeee"
        }]
      }, {
        "featureType": "water",
        "elementType": "geometry",
        "stylers": [{
          "color": "#c9c9c9"
        }]
      }, {
        "featureType": "water",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#9e9e9e"
        }]
      }];
    } else if (mapArray.mapstyle == 'night') {
      styleJson = [{
        "elementType": "geometry",
        "stylers": [{
          "color": "#242f3e"
        }]
      }, {
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#746855"
        }]
      }, {
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#242f3e"
        }]
      }, {
        "featureType": "administrative.locality",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#d59563"
        }]
      }, {
        "featureType": "poi",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#d59563"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "geometry",
        "stylers": [{
          "color": "#263c3f"
        }]
      }, {
        "featureType": "poi.park",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#6b9a76"
        }]
      }, {
        "featureType": "road",
        "elementType": "geometry",
        "stylers": [{
          "color": "#38414e"
        }]
      }, {
        "featureType": "road",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#212a37"
        }]
      }, {
        "featureType": "road",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#9ca5b3"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry",
        "stylers": [{
          "color": "#746855"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "geometry.stroke",
        "stylers": [{
          "color": "#1f2835"
        }]
      }, {
        "featureType": "road.highway",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#f3d19c"
        }]
      }, {
        "featureType": "transit",
        "elementType": "geometry",
        "stylers": [{
          "color": "#2f3948"
        }]
      }, {
        "featureType": "transit.station",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#d59563"
        }]
      }, {
        "featureType": "water",
        "elementType": "geometry",
        "stylers": [{
          "color": "#17263c"
        }]
      }, {
        "featureType": "water",
        "elementType": "labels.text.fill",
        "stylers": [{
          "color": "#515c6d"
        }]
      }, {
        "featureType": "water",
        "elementType": "labels.text.stroke",
        "stylers": [{
          "color": "#17263c"
        }]
      }];
    } else {
      styleJson = [];
    } //Create google maps link


    $('.js-map-link').attr('href', 'https://www.google.com/maps/place/' + mapArray.directions + '/@' + lat + ',' + lng); //Set map options

    var mapOptions = {
      zoom: mapArray.zoom,
      center: location,
      styles: styleJson,
      disableDefaultUI: false
    }; //Create map

    var map = new google.maps.Map(document.getElementById(mapArray.sectionid), mapOptions); //Show pin

    if (mapArray.showpin == true) {
      var marker = new google.maps.Marker({
        position: location,
        map: map
      });
    }
  }
};
/*============================================================================
  Collection
==============================================================================*/

window.collection = {
  init: function () {
    if (window.PXUTheme.theme_settings.collection_swatches) {
      if (window.PXUTheme.media_queries.large.matches) {
        $('.thumbnail').hover(function () {
          $('.swatch span', $(this)).each(function () {
            if ($(this).data("image").indexOf("no-image") == -1) {
              $('<img/>')[0].src = $(this).data("image");
            }
          });
        });
        $('.swatch span').hover(function () {
          if ($(this).data("image").indexOf("no-image") == -1) {
            $(this).parents('.thumbnail').find('img').attr('src', $(this).data("image"));
            $(this).parents('.thumbnail').find('img').attr('srcset', $(this).data("image"));
          }
        });
      }
    }

    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
      $(".quick_shop").remove();
    } else {
      if (window.PXUTheme.theme_settings.collection_secondary_image) {
        showSecondaryImage();
      }

      $('.quick_shop').fancybox({
        baseClass: 'quick-shop__lightbox',
        hash: false,
        infobar: false,
        animationDuration: 0,
        toolbar: false,
        loop: false,
        smallBtn: true,
        video: {
          autoStart: false
        },
        touch: false,
        mobile: {
          preventCaptionOverlap: false,
          toolbar: true,
          buttons: ["close"]
        },
        afterShow: function (e) {
          // When the modal is opened, prevent scrolling
          document.documentElement.classList.add('scroll-locked');
          var productUrl = $(e.current.src).data('url');
          _pixelunion_shopify_asyncview__WEBPACK_IMPORTED_MODULE_4__/* .default.load */ .Z.load(productUrl, {
            view: 'quickshop'
          }).then((_ref) => {
            let {
              data,
              html
            } = _ref;
            $(e.current.src + '.modal').html(html.content);
            window.product.init(); //Load accordions

            window.utils.initializeAccordion(); //Load tabs

            window.utils.initializeTabs(); // Initialize shopify payment buttons

            if (Shopify.PaymentButton) {
              Shopify.PaymentButton.init();
            } // Initialize product reviews


            if ($('#shopify-product-reviews').length >= 1) {
              SPR.$(document).ready(function () {
                return SPR.registerCallbacks(), SPR.initRatingHandler(), SPR.initDomEls(), SPR.loadProducts(), SPR.loadBadges();
              });
            }

            var selector = $('.fancybox-is-open').find('.selector-wrapper select');
            var $productForm = $('.fancybox-is-open .js-product_section').find('.product_form'); // Grab the fancybox element that is being clicked

            var $fancyboxImageElement = $(this.opts.$orig);
            $('.product_form').addClass('is-visible'); //Link sold out options when there is more than one option available (eg. S is selected and Yellow option appears as sold out)

            if (window.PXUTheme.theme_settings.product_form_style == 'swatches') {
              var JSONData = $productForm.data('product');
              var productID = $productForm.data('product-id');
              var productSection = '.product-' + productID + ' .js-product_section';
              var swatchOptions = $productForm.find('.swatch_options .swatch');

              if (swatchOptions.length > 1) {
                Shopify.linkOptionSelectors(JSONData, productSection);
              }
            }

            selector.trigger('change');
            var $gallery = $('.' + $fancyboxImageElement.data('gallery'));
            var galleryObject = {
              element: $gallery,
              thumbnailsEnabled: $gallery.parents('.product_section').data('thumbnails-enabled'),
              thumbnailsSliderEnabled: $gallery.parents('.product_section').data('thumbnails-slider-enabled'),
              thumbnailsPosition: $gallery.parents('.product_section').data('thumbnails-position'),
              thumbnailsArrows: $gallery.parents('.product_section').data('gallery-arrows-enabled'),
              slideshowAnimation: $gallery.parents('.product_section').data('slideshow-animation'),
              slideShowSpeed: $gallery.parents('.product_section').data('slideshow-speed'),
              activateZoom: $gallery.parents('.product_section').data('activate-zoom'),
              productMediaSupported: $gallery.parents('.product_section').data('product-media-supported'),
              loopingEnabled: $gallery.data('video-looping-enabled'),
              sectionID: null
            };

            if ($('.product-recommendations').length) {
              window.product.init();
            }

            window.product.enableSlider(galleryObject);

            if (galleryObject.productMediaSupported) {
              // Find videos within gallery section
              var thumbnailVideos;
              thumbnailVideos = $(galleryObject.element).find('[data-html5-video] video, [data-youtube-video]').get();
              window.product.loadPlyr(galleryObject, thumbnailVideos);
              window.product.launchProductMedia(galleryObject);
            } // Hover to Zoom


            if (galleryObject.activateZoom) {
              $gallery.parents('.product_section').find('.image__container img').each(function (index, image) {
                $(image).wrap('<span class="zoom-container"></span>').css('display', 'block').parent().zoom({
                  touch: false,
                  magnify: 1
                });
              });
            }
          });
        },
        afterClose: function () {
          // When the modal is closed, allow scrolling
          document.documentElement.classList.remove('scroll-locked'); // Grab the fancybox element that is being clicked

          var $fancyboxImageElement = $(this.opts.$orig);
          var $gallery = $('.' + $fancyboxImageElement.data('gallery')); // Empties Fancybox modal that is attached to product thumbnail

          $('.fancybox-modal').empty(); // Find videos in gallery
          // Find IDs and match against player
          // If videos are playing, pause them

          var $videosInGallery = $gallery.find('.product-gallery__image[data-media-type="video"], .product-gallery__image[data-media-type="external_video"]');
          $videosInGallery.each(function (index, video) {
            var $iframeVideo = $(video).find('iframe');
            var iframeID = $iframeVideo.attr('id');
            var $html5Video = $(video).find('[data-html5-video]');
            var videoID = $html5Video.find('video').data('plyr-video-id'); // Pause videos if IDs match

            if ($html5Video.length || $iframeVideo.length) {
              $.each(globalPlayersArray, function (index, player) {
                if (videoID) {
                  if (player.id == videoID && player.playing) {
                    player.pause();
                  }
                } else if (iframeID) {
                  if (player.media.id == iframeID && player.playing) {
                    player.pause();
                  }
                }
              });
            }
          });
        }
      });
    }

    if ($('[data-faceted-filters]').length) {
      facetedFiltering.init();
    }

    $('#sort-by').val($('#sort-by').data('default-sort'));
    $('body').on('change', '#sort-by', function () {
      var sortValue = $('#sort-by').val();
      Shopify.queryParams.sort_by = sortValue;
      var sortUrl = decodeURIComponent($.param(Shopify.queryParams));
      window.location = '?' + sortUrl;
    });
  },
  unload: function ($target) {
    $target.find('.thumbnail').off('mouseenter mouseleave');
    $('body').off('change', '#sort-by');
    $target.find('.quick_shop').off('click.fb');
    $target.find('[data-filter-modal-open]').off('click');
    $target.find('[data-range-filter-button]').off('click');
    $(window).off('resize.filtering');
  }
};
/*============================================================================
  Utils
==============================================================================*/

window.utils = {
  initializeTabs: function () {
    var tabs = $('ul.tabs');
    tabs.each(function (i) {
      var tab = $(this).find('> li > a');
      tab.on('click', function (e) {
        var contentLocation = $(this).attr('href');

        if (contentLocation.charAt(0) == "#") {
          e.preventDefault();
          tab.removeClass('active');
          $(this).addClass('active');
          $(this).parents('ul.tabs').next().find(contentLocation).show().css({
            'display': 'block'
          }).addClass('active').siblings().hide().removeClass('active');
        }
      });
    });
  },
  initializeAccordion: function () {
    //Load Accordions
    var allPanels = $('.accordion > dd');

    for (let i = 0; i < allPanels.length; i++) {
      if ($(allPanels[i]).parents('.size_chart_content').length == 0) {
        $(allPanels[i]).css('height', $(allPanels[i]).outerHeight());
      }
    }

    allPanels.hide();
    $('.accordion > dt > a').click(function () {
      if (!$(this).parent().next().is(':visible')) {
        allPanels.slideUp();
        $(this).parent().next().slideDown();
        $('.accordion small.right').html('&#9668;');
        $(this).find('small.right').html('&#9660;');
      }

      return false;
    });
    $('.accordion dd:first-of-type').show();
  },
  unload: function () {
    $('ul.tabs > li > a').off('click');
  }
};

var lazyload = function () {
  $(".primary").lazyload({
    skip_invisible: false,
    threshold: 400,
    effect: "fadeIn"
  });
};

var showSecondaryImage = function () {
  // Will be enabled on non-touch devices and screen sizes larger than 1024px
  if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) && window.matchMedia("(min-width: 1024px)").matches) {
    // Load Plyr for videos as secondary media
    var secondaryMediaVideos;
    const galleryObject = null;
    const showSecondaryMedia = true;
    secondaryMediaVideos = $('.thumbnail').find('[data-html5-video] video, [data-youtube-video]').get();
    window.product.loadPlyr(galleryObject, secondaryMediaVideos, showSecondaryMedia);
    $('.has-secondary-media-swap').on('mouseenter', function () {
      $(this).find('.image-element__wrap img').toggleClass('secondary-media-hidden');
      $(this).find('[data-html5-video]').toggleClass('secondary-media-hidden');
      $(this).find('.external-video__container').toggleClass('secondary-media-hidden');
      window.product.enableVideoOnHover($(this));
    });
    $('.has-secondary-media-swap').on('mouseleave', function () {
      $(this).find('.image-element__wrap img').toggleClass('secondary-media-hidden');
      $(this).find('[data-html5-video]').toggleClass('secondary-media-hidden');
      $(this).find('.external-video__container').toggleClass('secondary-media-hidden');
      window.product.disableVideoOnHover($(this));
    });
  }
};
/*============================================================================
  Utilities
==============================================================================*/


var plyrUtils = {
  playButtonIcon: '<button type="button" class="plyr__control plyr__control--overlaid" aria-label="Play, {title}" data-plyr="play"><svg class="play-icon-button-control" width="60" height="60" viewBox="0 0 60 60" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="60" height="60" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M23 20V40L39 29.4248L23 20Z" fill="#323232"/></svg><span class="plyr__sr-only">Play</span></button>',
  playButton: '<button type="button" class="plyr__controls__item plyr__control" aria-label="Play, {title}" data-plyr="play"><svg class="icon--pressed" role="presentation"><use xlink:href="#plyr-pause"></use></svg><svg class="icon--not-pressed" role="presentation"><use xlink:href="#plyr-play"></use></svg><span class="label--pressed plyr__tooltip" role="tooltip">Pause</span><span class="label--not-pressed plyr__tooltip" role="tooltip">Play</span></button>',
  muteButton: '<button type="button" class="plyr__controls__item plyr__control" aria-label="Mute" data-plyr="mute"><svg class="icon--pressed" role="presentation"><use xlink:href="#plyr-muted"></use></svg><svg class="icon--not-pressed" role="presentation"><use xlink:href="#plyr-volume"></use></svg><span class="label--pressed plyr__tooltip" role="tooltip">Unmute</span><span class="label--not-pressed plyr__tooltip" role="tooltip">Mute</span></button>',
  progressInput: '<div class="plyr__controls__item plyr__progress__container"><div class="plyr__progress"><input data-plyr="seek" type="range" min="0" max="100" step="0.01" value="0" aria-label="Seek"><progress class="plyr__progress__buffer" min="0" max="100" value="0">% buffered</progress><span role="tooltip" class="plyr__tooltip">00:00</span></div></div>',
  volume: '<div class="plyr__controls__item plyr__volume"><input data-plyr="volume" type="range" min="0" max="1" step="0.05" value="1" autocomplete="off" aria-label="Volume"></div>',
  fullscreen: '<button type="button" class="plyr__controls__item plyr__control" data-plyr="fullscreen"><svg class="icon--pressed" role="presentation"><use xlink:href="#plyr-exit-fullscreen"></use></svg><svg class="icon--not-pressed" role="presentation"><use xlink:href="#plyr-enter-fullscreen"></use></svg><span class="label--pressed plyr__tooltip" role="tooltip">Exit fullscreen</span><span class="label--not-pressed plyr__tooltip" role="tooltip">Enter fullscreen</span></button>'
};
var controls = plyrUtils.playButtonIcon + '<div class="plyr__controls">' + plyrUtils.playButton + plyrUtils.progressInput + plyrUtils.muteButton + plyrUtils.volume + plyrUtils.fullscreen + '</div';
var globalPlayersArray = [];
var secondaryMediaPlayers;
window.utilities = {
  listenForResize: function () {
    // Setup a timer
    var resizeTimeout; // Listen for resize events

    window.addEventListener('resize', function (event) {
      // If timer is null, reset it to 66ms and run your functions.
      // Otherwise, wait until timer is cleared
      if (!resizeTimeout) {
        resizeTimeout = setTimeout(function () {
          // Reset timeout
          resizeTimeout = null; // Run our resize functions
        }, 66);
      }
    }, false);
  },
  enableDisclosure: function () {
    var $disclosure = $('[data-disclosure]');
    var $toggle = $('[data-disclosure-toggle]');
    var $disclosureWrap = $('.disclosure__list-wrap'); //Check if current opened menu is offscreen

    function checkOffScreen($openedToggle) {
      if ($openedToggle.siblings('.disclosure__list-wrap').is(':off-right')) {
        $openedToggle.siblings('.disclosure__list-wrap').addClass('disclosure--left');
      }
    }

    function closeDisclosures(ignoreTarget, currentTarget) {
      if (ignoreTarget === true) {
        $toggle.not(currentTarget).removeClass('is-clicked');
        $toggle.not(currentTarget).attr('aria-expanded', 'false');
      } else {
        $toggle.removeClass('is-clicked');
        $toggle.attr('aria-expanded', 'false');
      }

      $disclosureWrap.removeClass('disclosure--left');
    } //Close menus on ESC


    $('body').on('keyup', function (e) {
      if (e.which == '27') {
        closeDisclosures();
      }
    }); //Close menus on hoverout

    $disclosure.on('mouseleave', function (e) {
      closeDisclosures();
    }); //On click/focus event for toggling options

    $toggle.on('mouseenter', function (e) {
      //Close all other menus
      closeDisclosures(true, this);
      var $target = $(e.currentTarget);
      $target.attr('aria-expanded', 'true').addClass('is-clicked');
      checkOffScreen($target);
    });
    $toggle.on('keyup', function (e) {
      if (e.which === 13) {
        var $target = $(e.currentTarget);
        $target.attr('aria-expanded', 'true').addClass('is-clicked');
        checkOffScreen($target);
      }
    });
    $disclosure.on('focusout', function (e) {
      const list = e.currentTarget;
      const nextEl = e.relatedTarget; // The element that would receive focus.
      // If the nextEl is within the list (a list item), don't close the list

      if (!list.contains(nextEl)) {
        closeDisclosures(false, this);
      }
    }); //Mobile toggle logic

    $toggle.on('touchstart', function (e) {
      if (window.PXUTheme.media_queries.medium.matches || !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        var $target = $(e.currentTarget);
        closeDisclosures(true, this);

        if (!$target.hasClass('is-clicked')) {
          $target.attr('aria-expanded', 'true').addClass('is-clicked');
          checkOffScreen($target);
        } else {
          $target.attr('aria-expanded', 'false').removeClass('is-clicked');
          $disclosureWrap.removeClass('disclosure--left');
        }
      }
    });
  },
  addImageDimension: function (imageUrl, size) {
    var insertPosition = imageUrl.lastIndexOf(".");
    return imageUrl.substring(0, insertPosition) + size + imageUrl.substring(insertPosition);
  },
  launchVideoPlayer: function (Plyr, galleryObject, videos, showSecondaryMedia) {
    if (galleryObject != null) {
      galleryObject.videoPlayers = Plyr.setup(videos, {
        controls: controls,
        fullscreen: {
          enabled: true,
          fallback: true,
          iosNative: true
        },
        storage: {
          enabled: false
        }
      }); // Going through galleries array and pushing players into master array

      $.each(galleryObject.videoPlayers, function (index, player) {
        globalPlayersArray.push(player);
      });
    } else if (showSecondaryMedia == true) {
      // Collection page/Recommended Products secondary media
      secondaryMediaPlayers = Plyr.setup(videos, {
        controls: controls,
        fullscreen: {
          enabled: true,
          fallback: true,
          iosNative: true
        },
        storage: {
          enabled: false
        }
      });
      $.each(secondaryMediaPlayers, function (index, player) {
        globalPlayersArray.push(player);
      }); // Adds plyr video id to video wrapper

      $.each(globalPlayersArray, function (index, player) {
        var source = player.provider;
        var id = player.id;
        var $video;

        if (source == 'html5') {
          $video = $(player.elements.wrapper).find('video');
          $video.attr('data-plyr-video-id', id);
        }
      });
      return secondaryMediaPlayers;
    }
  },
  unload: function () {
    $('[data-disclosure]').off();
    $('[data-disclosure-toggle]').off();
    $('.disclosure__list-wrap').off();
  }
};

var toggleSidebarBlocks = function ($toggle) {
  if ($toggle.parent().next('ul').is(':visible')) {
    $toggle.parent().next('ul').hide();
    $toggle.html('+');
    $toggle.attr('aria-expanded', false);
  } else {
    $toggle.parent().next('ul').show();
    $toggle.html('-');
    $toggle.attr('aria-expanded', true);
  }
};

var toggleSidebarMenus = function ($toggle) {
  const $menu = $toggle.parent('li');
  const $toggleIcon = $menu.children('.menu-toggle');
  $toggleIcon.toggleClass('active');
  $menu.children('ul').slideToggle();
  $toggleIcon.attr('aria-expanded', $toggleIcon.attr('aria-expanded') == 'true' ? 'false' : 'true');
};

var sliderBlock = {
  select: function (blockId, $parentSection) {
    var $blocks = $parentSection.find('.slideshow__gallery-cell');
    var blockIdsArray = $blocks.map(function () {
      return String($(this).data('block-id'));
    });
    var $slider = $parentSection.find('[data-slider-id]');
    var flkty = $slider.data('flickity');
    $slider.flickity('pausePlayer');

    for (var i = 0; i < blockIdsArray.length; i++) {
      if (blockIdsArray[i] === blockId) {
        var currentSlide = i;

        if (currentSlide !== flkty.selectedIndex) {
          $slider.flickity('select', parseInt(currentSlide), false, true);
        }
      }
    }
  },
  deselect: function ($parentSection) {
    var $slider = $parentSection.find('[data-slider-id]');

    if ($slider) {
      $slider.flickity('unpausePlayer');
    }
  }
}; //Document ready

$(function () {
  window.lazySizesConfig = window.lazySizesConfig || {};
  window.lazySizesConfig.expand = 1000;
  window.lazySizesConfig.loadMode = 1;
  document.documentElement.style.setProperty('--scrollbar-width', window.innerWidth - document.documentElement.clientWidth + "px"); //Load sections

  window.header.init();
  window.map.init();
  window.slideshow.init();
  window.collection.init();
  window.product.init();
  window.product.initializeQuantityBox();
  window.video.init();
  window.faqAccordion.init(); //Init lazyload

  lazyload(); //Init objectFitImages

  objectFitImages();

  if (window.PXUTheme.theme_settings.enable_predictive_search) {
    predictiveSearch.init();
  }

  var linkTarget = $('.js-navigation li a');
  linkTarget.mousedown(function () {
    $(this).data('mousedown', true);
  });
  linkTarget.focus(function (e) {
    if (!$(this).data('mousedown')) {
      $(this).parents('li.dropdown, .sub-menu').attr('aria-expanded', 'true').addClass('show-menu');
    }
  });
  linkTarget.blur(function () {
    $(this).data('mousedown', false);
    $('li.dropdown, .sub-menu').removeClass('show-menu').attr('aria-expanded', 'false');
  }); // Initialize Responsive Videos

  enableResponsiveVideoWrapper(); //offscreen check for dropdown menu

  $('.sub-menu').not('.slicknav_parent').on('mouseenter', function () {
    if ($(this).find('.submenu_list').is(':off-right')) {
      $(this).find('.submenu_list').addClass("submenu--align-right");
    }

    if ($(this).find('.sub_submenu_list').is(':off-right')) {
      $(this).find('.sub_submenu_list').addClass("submenu--align-right");
    }
  }); //Lightbox default options
  //https://fancyapps.com/fancybox/3/docs/#options

  $.fancybox.defaults.animationEffect = 'fade';
  $.fancybox.defaults.transitionEffect = 'fade';
  $.fancybox.defaults.hash = false;
  $.fancybox.defaults.infobar = false;
  $.fancybox.defaults.toolbar = false;
  $.fancybox.defaults.arrows = false;
  $.fancybox.defaults.loop = true;
  $.fancybox.defaults.smallBtn = true;
  $.fancybox.defaults.wheel = false;
  $.fancybox.defaults.live = false;
  $.fancybox.defaults.zoom = false;
  $.fancybox.defaults.btnTpl['smallBtn'] = '<a title="Close" data-fancybox-close class="fancybox-item fancybox-close" href="javascript:;"></a>';
  $.fancybox.defaults.mobile.preventCaptionOverlap = false;
  $.fancybox.defaults.mobile.toolbar = true;
  $.fancybox.defaults.mobile.buttons = ['close'];
  $.fancybox.defaults.mobile.clickSlide = 'close';
  $.fancybox.defaults.mobile.clickContent = 'zoom';

  $.fancybox.defaults.afterLoad = function (instance, slide) {
    if (instance.current.type == 'image') {
      slide.$content.wrapInner("<div class='fancybox-image-wrap'></div>");
    }

    if (instance.group.length > 1) {
      slide.$content.find('.fancybox-image-wrap').append('<a title="Previous" class="fancybox-item fancybox-nav fancybox-prev ss-icon" href="javascript:;" data-fancybox-prev><span></span></a><a title="Next" class="fancybox-item fancybox-nav fancybox-next ss-icon" href="javascript:;" data-fancybox-next><span></span></a>');
    }
  }; //backwards compatibility with custom lightboxes


  $('.lightbox').fancybox(); // Gallery fancybox initialization

  $('[rel="gallery"]').fancybox({
    baseClass: "gallery-section__lightbox",
    clickContent: "nextOrClose"
  }); // Trigger fancybox flickity product gallery images

  $('.product-gallery__main .product-gallery__image .fancybox').fancybox({
    baseClass: "product-section__lightbox",
    clickContent: "nextOrClose",
    transitionEffect: 'slide',
    beforeShow: function () {
      // Grab the fancybox element that is being clicked
      var $fancyboxImageElement = $(this.opts.$orig); // Add alt to fancybox image

      var imageAlt = $fancyboxImageElement.data('alt');
      $('.fancybox-image').attr('alt', imageAlt);
    }
  });

  if (window.PXUTheme.currency.shipping_calculator && document.querySelector('[data-cart-shipping]')) {
    const shippingCalculator = new _helpers_ShippingCalculator__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z({
      el: document.querySelector('[data-cart-shipping]')
    });
  }

  if (window.PXUTheme.theme_settings.newsletter_popup) {
    newsletter_popup.init();
  } // Cart page functions - check subtotal and input updates


  $('.update_subtotal').click(function () {
    // This is handled by the fetch API mechanism below
    return false;
  });
  
  //Terms and conditions agreement check

  addToCartTermsCheck();

  // Debug: Check if we're on cart page
  console.log(' JavaScript loaded - checking for cart page');
  if (window.location.pathname.indexOf('/cart') !== -1) {
    console.log(' CART PAGE DETECTED - Setting up handlers');
    
    // Debug: Check if quantity inputs exist
    var quantityInputs = document.querySelectorAll('input.quantity[data-line-id]');
    console.log('Found', quantityInputs.length, 'quantity inputs with data-line-id');
    
    quantityInputs.forEach(function(input, index) {
      console.log('Input', index, ':', input.className, 'data-line-id:', input.getAttribute('data-line-id'), 'value:', input.value);
    });
    
    // Test the selector
    console.log('Testing selector input.quantity[data-line-id]:', document.querySelectorAll('input.quantity[data-line-id]').length);
    console.log('All quantity inputs:', document.querySelectorAll('input.quantity').length);
    console.log('All inputs with data-line-id:', document.querySelectorAll('input[data-line-id]').length);
    
    // Test if event listener is working
    console.log(' Event listeners attached - try changing a quantity to see debug output');
  }

  // Handle contact form submission - update cart first, then submit contact form
  document.addEventListener('submit', function (e) {
    var form = e.target;
    if (form.id === 'cart_form' && form.tagName === 'FORM') {
      console.log('Contact form submitted - updating cart first');
      e.preventDefault(); // Prevent default form submission
      
      // Get all quantity inputs and update cart
      var quantityInputs = form.querySelectorAll('input[data-line-id]');
      var updates = {};
      
      quantityInputs.forEach(function(input) {
        var line = parseInt(input.getAttribute('data-line-id'), 10);
        var quantity = parseInt(input.value, 10);
        if (!isNaN(quantity) && quantity >= 0 && line > 0) {
          updates[line] = quantity;
        }
      });
      
      console.log('Cart updates:', updates);
      
      // Update cart first
      fetch('/cart/update.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ updates: updates })
      })
      .then(function(res) { return res.json(); })
      .then(function(cart) {
        console.log('Cart updated successfully:', cart.item_count, 'items');
        
        // Update all cart count elements
        document.querySelectorAll('.cart_count, .quote-cart-count-top, .quote-cart-count, .cart-count-number, [class*="ai-top-header-bar-cart-count"]').forEach(function(node){
          node.textContent = cart.item_count;
        });
        
        // Call refreshCart function
        if (typeof refreshCart === 'function') {
          refreshCart(cart);
        }
        
        // Now submit the contact form
        console.log('Submitting contact form...');
        form.submit();
      })
      .catch(function(error) {
        console.error('Cart update error:', error);
        alert('Error updating cart. Please try again.');
      });
    }
  });

  // Handle both direct input changes and button clicks
  document.addEventListener('change', function (e) {
    handleQuantityChange(e.target);
  });
  
  // Also handle plus/minus button clicks
  document.addEventListener('click', function (e) {
    if (e.target.closest('.js-change-quantity')) {
      console.log(' Plus/minus button clicked');
      // Wait a moment for the value to update, then handle the change
      setTimeout(function() {
        var input = e.target.closest('.purchase-details__quantity, .cart--info-wrapper').querySelector('input.quantity[data-line-id]');
        if (input) {
          console.log(' Handling button click change for input:', input);
          handleQuantityChange(input);
        }
      }, 100);
    }
  });

  function handleQuantityChange(el) {
    console.log('=== CHANGE EVENT DEBUG ===');
    console.log('Element:', el);
    console.log('Tag:', el.tagName);
    console.log('Classes:', el.className);
    console.log('Data-line-id:', el.getAttribute('data-line-id'));
    console.log('Name:', el.name);
    console.log('Value:', el.value);
    console.log('========================');
    
    // Only act on cart quantity inputs
    if (!el.matches('input.quantity[data-line-id]')) {
      console.log('Not a cart quantity input, skipping');
      return;
    }
    
    console.log(' This is a cart quantity input - proceeding with update');

    var qty = parseInt(el.value, 10);
    if (isNaN(qty) || qty < 0) qty = 0;

    var line = parseInt(el.getAttribute('data-line-id'), 10);
    if (!line || line < 1) {
      console.log('Invalid line ID:', line); // Debug log
      return;
    }

    console.log(' CART UPDATE REQUEST:');
    console.log('Line:', line);
    console.log('Quantity:', qty);
    console.log('Request body:', JSON.stringify({ line: Number(line), quantity: Number(qty) }));

    el.disabled = true;
    el.classList.add('is-updating');

    fetch('/cart/change.js', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ line: Number(line), quantity: Number(qty) })
    })
    .then(function(res){ 
      console.log(' API Response status:', res.status);
      console.log(' API Response headers:', res.headers);
      return res.json(); 
    })
    .then(function(cart){
      console.log(' CART UPDATE SUCCESS:');
      console.log('Cart object:', cart);
      console.log('Item count:', cart.item_count);
      console.log('Items:', cart.items);
      
      // Update all cart count elements
      document.querySelectorAll('.cart_count, .quote-cart-count-top, .quote-cart-count, .cart-count-number, [class*="ai-top-header-bar-cart-count"]').forEach(function(node){
        node.textContent = cart.item_count;
      });

      // Also try more specific selectors for AI header
      document.querySelectorAll('[class*="ai-top-header-bar-cart-count"]').forEach(function(node){
        node.textContent = cart.item_count;
      });

      // Call the refreshCart function as well to ensure consistency
      if (typeof refreshCart === 'function') {
        refreshCart(cart);
      }

      // Don't reload cart page, just re-enable input and update display
      el.disabled = false;
      el.classList.remove('is-updating');
      
      // Update the cart item display on the page
      var $cartItem = el.closest('.cart--info-wrapper');
      if ($cartItem.length) {
        // Update any price displays or other cart item info if needed
        var $priceDisplay = $cartItem.find('.price_total .money');
        if ($priceDisplay.length && cart.items) {
          // Find the matching cart item and update price if needed
          var lineId = parseInt(el.getAttribute('data-line-id'), 10);
          var matchingItem = cart.items.find(function(item, index) {
            return (index + 1) === lineId;
          });
          if (matchingItem) {
            // Update price display if needed
            // This is optional - the main cart count update is what we need
          }
        }
      }
    })
    .catch(function(error) {
      console.error(' CART UPDATE ERROR:');
      console.error('Error object:', error);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      console.error('Error name:', error.name);
      el.disabled = false;
      el.classList.remove('is-updating');
    });
  }

  Shopify.queryParams = {};

  if (location.search.length) {
    for (var aKeyValue, i = 0, aCouples = location.search.substr(1).split('&'); i < aCouples.length; i++) {
      aKeyValue = aCouples[i].split('=');

      if (aKeyValue.length > 1) {
        Shopify.queryParams[aKeyValue[0]] = aKeyValue[1];
      }
    }
  } //Load language/currency switchers


  window.utilities.enableDisclosure(); //Load accordions

  window.utils.initializeAccordion(); //Load tabs

  window.utils.initializeTabs(); //Sidebar toggle

  $(document).on('click', '.menu-toggle, .parent-link--false', function (e) {
    toggleSidebarMenus($(this));
  });
  var sidebarTouched = false;
  $(document).on('touchstart', '.toggle span', function (e) {
    if (window.PXUTheme.media_queries.medium.matches || $(this).parents('.sidebar').hasClass('toggle-all--true')) {
      var $toggle = $(this);
      toggleSidebarBlocks($toggle);
      sidebarTouched = true;
      e.preventDefault();
      return false;
    }
  });
  $(document).on('click', '.toggle span', function (e) {
    if (window.PXUTheme.media_queries.medium.matches || $(this).parents('.sidebar').hasClass('toggle-all--true')) {
      var $toggle = $(this);

      if (!sidebarTouched) {
        toggleSidebarBlocks($toggle);
        e.preventDefault();
        return false;
      }
    }
  });
  $(document).on('keyup', '.toggle span', function (e) {
    if (!$('body').hasClass('user-is-tabbing')) return;

    if (e.key === 'Enter') {
      if (window.PXUTheme.media_queries.medium.matches || $(this).parents('.sidebar').hasClass('toggle-all--true')) {
        var $toggle = $(this);

        if (!sidebarTouched) {
          toggleSidebarBlocks($toggle);
          e.preventDefault();
          return false;
        }
      }
    }
  });
  $(".toggle_list").each(function () {
    if ($(this).is(":visible")) {
      $(this).prev(".toggle").attr("aria-expanded", true);
    }
  }); // Backwards compatibility with flexslider

  $('.cc-slideshow, .flexslider').find('li').unwrap();
  $('.cc-slideshow, .flexslider').flickity({
    pageDots: false,
    autoPlay: 6000,
    imagesLoaded: true,
    wrapAround: true,
    lazyLoad: 2,
    adaptiveHeight: true
  });
  /*============================================================================
    Responsive media
  ==============================================================================*/

  function enableResponsiveVideoWrapper() {
    // Wraps YouTube and Vimeo iframes in Plyr wrapper
    // Does not target iframes already embedded in Plyr wrapper (video sections and product galleries)
    $('iframe[src*="youtube.com"]:not(.plyr__video-wrapper iframe[src*="youtube.com"])').wrap('<div class="plyr__video-embed"></div>');
    $('iframe[src*="vimeo.com"]:not(.plyr__video-wrapper iframe[src*="vimeo.com"])').wrap('<div class="plyr__video-embed"></div>');
  }
  /*============================================================================
    Start of cart-related functionality
  ==============================================================================*/


  function ajaxSubmitCart() {
    $cart = $("#cart");
    $.ajax({
      url: '/cart.js',
      dataType: 'json',
      type: 'post',
      data: $cart.serialize(),
      success: function (data) {
        refreshCart(data);
      }
    });
  }

  function refreshCart(cart) {
    const $cartBtn = $(".cart_button");

    if ($cartBtn) {
      var $cartCount = $cartBtn.find('.cart_count');

      if ($cartCount.length) {
        $cartCount.text(cart.item_count);
      }
    }

    // Update simple floating quote cart if present
    var $floating = $('.quote-cart-count');
    if ($floating.length) {
      $floating.text(cart.item_count);
    }
    var $top = $('.quote-cart-count-top');
    if ($top.length) {
      $top.text(cart.item_count);
    }

    // Update AI generated header cart count
    $('[class^="ai-top-header-bar-cart-count-"]').text(cart.item_count);
  } //Terms and conditions agreement check


  function addToCartTermsCheck() {
    if ($('.tos_agree').length) {
      $('body').on('click', '#checkout', function () {
        if ($('.tos_agree').is(':checked')) {
          $(this).submit();
        } else {
          alert(window.PXUTheme.translation.agree_to_terms_warning);
          return false;
        }
      });
    }
  }

  if (window.PXUTheme.theme_settings.cart_action == 'ajax') {
    $(document).on('click', '.ajax-submit', function (e) {
      e.preventDefault();
      var $addToCartForm = $(this).closest('form');
      var $addToCartInfo = $(this).parent('.product_form');
      var $addToCartBtn = $addToCartForm.find('.add_to_cart');
      this.recipientForm = $addToCartForm[0].querySelector('[data-recipient-form]');
      $('.warning').remove();

      if (this.recipientForm) {
        this.recipientForm.classList.remove('recipient-form--has-errors');
      }

      $.ajax({
        url: '/cart/add.js',
        dataType: 'json',
        type: 'post',
        data: $addToCartForm.serialize(),
        beforeSend: function () {
          $addToCartBtn.attr('disabled', 'disabled').addClass('disabled');
          $addToCartBtn.find('span').removeClass("zoomIn").addClass('animated zoomOut');
        },
        success: function (item) {
          var itemDiscounts = item.discounts;
          var discountMessage = "";

          for (let i = 0; i < itemDiscounts.length; i++) {
            var amount = Shopify.formatMoney(itemDiscounts[i].amount, $('body').data('money-format'));
            var title = itemDiscounts[i].title;
            discountMessage = '<span class="notification-discount"><b>' + window.PXUTheme.translation.cart_discount + ':</b> ' + title + ' (- <span class="money">' + amount + '</span>)</span>';
          }

          $addToCartBtn.find('span').text(window.PXUTheme.translation.product_add_to_cart_success).removeClass('zoomOut').addClass('fadeIn');
          var padding = [20, 40, 20, 40];
          window.setTimeout(function () {
            var hasImage = true;

            if (item.image !== null) {
              hasImage = true;
            } else {
              hasImage = false;
            }

            $.fancybox.close(); // Update the checkout URL based on the selected language

            if (window.PXUTheme.theme_settings.primary_locale === 'true') {
              var currentCheckout = window.PXUTheme.theme_settings.shop_url + 'checkout';
            } else {
              var currentCheckout = window.PXUTheme.theme_settings.shop_url + '/checkout';
            } // Define unit price


            let unitPriceOutput = '';
            let unitPriceMeasurementReferenceValue = '';

            if (item.unit_price_measurement) {
              if (item.unit_price_measurement.reference_value != 1) {
                unitPriceMeasurementReferenceValue = item.unit_price_measurement.reference_value;
              }

              unitPriceOutput += `
                <p class="cart-notification__unit-price">
                  ${item.unit_price_measurement.quantity_value}${item.unit_price_measurement.quantity_unit} | ${Shopify.formatMoney(item.unit_price, $('body').data('money-format'))} / ${unitPriceMeasurementReferenceValue}${item.unit_price_measurement.reference_unit}
                </p>
              `;
            }

            if (hasImage) {
              $.fancybox.open($(`
                <div
                  class="
                    cart-notification
                    is-inline-flex
                    is-align-center
                  "
                >
                  <div class="cart-notification__image is-hidden-mobile-only">
                    <img src="${item.image.replace(/(\.[^.]*)$/, "_grande$1").replace('https:', '')}" alt="${htmlEncode(item.title)}">
                  </div>

                  <div class="cart-notification__content">
                    <div class="cart-notification__view">
                      <a href="${window.PXUTheme.routes.cart_url}">
                        ${window.PXUTheme.translation.edit_cart}
                      </a>
                    </div>

                    <h4 class="cart-notification__title">
                      <span class="icon-check"></span> ${window.PXUTheme.translation.add_to_cart_success}
                    </h4>

                    <p class="cart-notification__item-title">
                      ${item.title}
                    </p>

                    <p class="cart-notification__price">
                      ${item.quantity} x
                      <span class="money">
                        ${Shopify.formatMoney(item.price, $('body').data('money-format'))}
                      </span>
                      ${discountMessage}
                    </p>

                    ${unitPriceOutput}

                    {% if settings.display_tos_checkbox %}
                      <div class="popup_tos">
                        <div class="tos_checkbox">
                          <input
                            class="tos_agree"
                            id="cart_agree"
                            type="checkbox"
                            required
                          >

                          <label class="tos_label" for="cart_agree">
                            {% if settings.tos_richtext != blank %}
                              ${window.PXUTheme.theme_settings.tos_richtext}
                            {% else %}
                              ${window.PXUTheme.translation.agree_to_terms_html}
                            {% endif %}
                          </label>
                        </div>
                      </div>
                    {% endif %}

                    <div class="cart-notification__checkout">
                      <a
                        class="action_button"
                        id="checkout"
                        href="${currentCheckout}"
                      >
                        ${window.PXUTheme.translation.checkout}
                      </a>
                      &nbsp;
                      <span class="continue_shopping">
                        ${window.PXUTheme.translation.or}
                        <a href="javascript:$.fancybox.close();">${window.PXUTheme.translation.continue_shopping}
                          <span class="icon-right-arrow"></span>
                        </a>
                      </span>
                    </div>
                  </div>
                </div>
              `), {
                padding: padding,
                wrapCSS: 'fancybox-cart-notification'
              });
            } else {
              $.fancybox.open($(`
                <div
                  class="
                    cart-notification
                    is-inline-flex
                    is-align-center
                  "
                >
                  <div class="cart-notification__content">
                    <div class="cart-notification__view">
                      <a href="/cart">
                        ${window.PXUTheme.translation.edit_cart}
                      </a>
                    </div>

                    <h4 class="cart-notification__title">
                      <span class="icon-check"></span> ${window.PXUTheme.translation.add_to_cart_success}
                    </h4>

                    <p class="cart-notification__item-title">
                      ${item.title}
                    </p>

                    <p class="cart-notification__price">
                      ${item.quantity} x
                      <span class="money">
                        ${Shopify.formatMoney(item.price, $('body').data('money-format'))}
                      </span>
                      ${discountMessage}
                    </p>

                    ${unitPriceOutput}

                    {% if settings.display_tos_checkbox %}
                      <div class="popup_tos">
                        <div class="tos_checkbox">
                          <input
                            class="tos_agree"
                            id="cart_agree"
                            type="checkbox"
                            required
                          >

                          <label class="tos_label" for="cart_agree">
                            {% if settings.tos_richtext != blank %}
                              ${window.PXUTheme.theme_settings.tos_richtext}
                            {% else %}
                              ${window.PXUTheme.translation.agree_to_terms_html}
                            {% endif %}
                          </label>
                        </div>
                      </div>
                    {% endif %}

                    <div class="cart-notification__checkout">
                      <a
                        class="action_button"
                        id="checkout"
                        href="${currentCheckout}"
                      >
                        ${window.PXUTheme.translation.checkout}
                      </a>
                      &nbsp;
                      <span class="continue_shopping">
                        ${window.PXUTheme.translation.or}
                        <a href="javascript:$.fancybox.close();">
                          ${window.PXUTheme.translation.continue_shopping}
                          <span class="icon-right-arrow"></span>
                        </a>
                      </span>
                    </div>
                  </div>
                </div>
              `), {
                padding: padding,
                wrapCSS: 'fancybox-cart-notification'
              });
            } // Terms and conditions agreement check


            addToCartTermsCheck();
          }, 500);
          window.setTimeout(function () {
            $addToCartBtn.removeAttr('disabled').removeClass('disabled');
            $addToCartBtn.find('span').addClass("fadeOut").text($addToCartBtn.data('label')).removeClass('fadeIn').removeClass("fadeOut").addClass('zoomIn');
          }, 1000);
          $.getJSON("/cart.js", function (cart) {
            refreshCart(cart);
          });
        },
        error: XMLHttpRequest => {
          var response = eval('(' + XMLHttpRequest.responseText + ')');
          $('.warning').remove();
          let warning;

          if (response.errors && response.errors.email) {
            this.recipientForm.classList.add('recipient-form--has-errors');
          } else {
            warning = '<p class="warning animated bounceIn">' + response.description.replace('All 1 ', 'All ') + '</p>';
            $addToCartForm.after(warning);
          }

          $addToCartBtn.removeAttr('disabled').removeClass('disabled');
          $addToCartBtn.find('span').text(window.PXUTheme.translation.product_add_to_cart).removeClass('zoomOut').addClass('zoomIn');
        }
      });
      return false;
    });
  }
}); // Function only triggers for products with variants

window.selectCallback = function (variant, selector) {
  var $product = $('.product-' + selector.product.id);
  var $notify_form = $('.notify-form-' + selector.product.id);
  var $productForm = $('.product_form', $product);
  var variantInventory = $productForm.data('variant-inventory');
  var $notifyFormInputs = $('.notify_form__inputs', $product);
  var notifyEmail = window.PXUTheme.translation.product_notify_form_email;
  var notifyEmailValue = "{{ contact.fields.email }}";
  var notifySend = window.PXUTheme.translation.product_notify_form_send;
  var notifyMessage = $notifyFormInputs.data('notify-message');

  if (variant && variant.title) {
    notifyMessage = notifyMessage + ' - ' + variant.title.replace(/"/g, '\&quot;');
  }

  if ($notifyFormInputs.hasClass('customer--true')) {
    var notifyCustomerEmail = "{{ customer.email }}";
    var notifyEmailInput = '<input type="hidden" class="notify_email" name="contact[email]" id="contact[email]" value="' + notifyCustomerEmail + '" />';
  } else {
    var notifyEmailInput = '<input required type="email" class="notify_email" name="contact[email]" id="contact[email]" placeholder="' + notifyEmail + '" value="' + notifyEmailValue + '" />';
  }

  var notifyFormHTML = notifyEmailInput + '<input type="hidden" name="challenge" value="false" /><input type="hidden" name="contact[body]" class="notify_form_message" value="' + notifyMessage + '" /><input class="action_button" type="submit" value="' + notifySend + '" style="margin-bottom:0px" />'; // Image variant feature

  if (variant && variant.featured_image && $product.is(":visible")) {
    var $sliders = $('.product-gallery__main', $product);
    $sliders.each(function () {
      var $slider = $(this);
      var $sliderInstance = Flickity.data(this);

      if ($slider.is(":visible") && $sliderInstance != undefined) {
        var index = $('[data-image-id="' + variant.featured_image.id + '"]').data('index');
        $sliderInstance.select(index, false, true);
      }
    });
  } // Quick Shop


  if (variant && variant.featured_image && $product.is(":visible")) {
    var $popimg = $('.modal_image', $product);
    var pop_original_image = $(".modal_image img", $product),
        new_image = variant.featured_image;
    Shopify.Image.switchImage(new_image, pop_original_image[0], function (new_image_src, pop_original_image, element) {
      $popimg.html('<img src="' + variant.featured_image.src + '"/>');
    });
  } // Unit price


  let unitPriceMeasurementReferenceValue = '';
  let unitPriceOutput = '';

  if (variant) {
    if (variantInventory) {
      variantInventory.forEach(function (v) {
        if (v.id === variant.id) {
          variant.inventory_quantity = v.inventory_quantity;
          variant.inventory_management = v.inventory_management;
          variant.inventory_policy = v.inventory_policy;
        }
      });
    }

    $('.sku', $product).text(variant.sku);

    if (window.PXUTheme.theme_settings.product_form_style == "swatches") {
      for (let i = 0, length = variant.options.length; i < length; i++) {
        var radioButton = $productForm.find('.swatch[data-option-index="' + escape(i) + '"] :radio[value="' + variant.options[i].replace(/\"/g, '\\"') + '"]');

        if (radioButton.length) {
          radioButton.get(0).checked = true;
        }
      }
    }

    if (variant.unit_price_measurement) {
      if (variant.unit_price_measurement.reference_value != 1) {
        unitPriceMeasurementReferenceValue = variant.unit_price_measurement.reference_value;
      }

      unitPriceOutput += `<div class="item_unit-price">${variant.unit_price_measurement.quantity_value}${variant.unit_price_measurement.quantity_unit} | ${Shopify.formatMoney(variant.unit_price, $('body').data('money-format'))} / ${unitPriceMeasurementReferenceValue}${variant.unit_price_measurement.reference_unit}</div>`;
    }
  }

  const $unitPrice = $('.product-details__unit-price', $product);
  $unitPrice.removeClass('product-details__unit-price--hidden');

  if (variant && variant.available == true) {
    if (variant.price < variant.compare_at_price) {
      $('.was-price', $product).html('<span class="money">' + Shopify.formatMoney(variant.compare_at_price, $('body').data('money-format')) + '</span>');
      $('.current-price', $product).parent().addClass('sale');
    } else {
      $('.was-price', $product).html('');
      $('.current-price', $product).parent().removeClass('sale');
    }

    if (variant.inventory_management && variant.inventory_quantity > 0) {
      if (window.PXUTheme.theme_settings.display_inventory_left) {
        if (variant.inventory_quantity == 1) {
          var items_left_text = window.PXUTheme.translation.items_left_count_one;
        } else {
          var items_left_text = window.PXUTheme.translation.items_left_count_other;
        }

        var inventoryThreshold = window.PXUTheme.theme_settings.inventory_threshold;

        if (variant.inventory_quantity <= inventoryThreshold) {
          $('.items_left', $product).html(variant.inventory_quantity + " " + items_left_text);
        } else {
          $('.items_left', $product).html("");
        }
      }

      if (window.PXUTheme.theme_settings.limit_quantity) {
        if (variant.inventory_policy == "deny") {
          $('.quantity', $product).attr('max', variant.inventory_quantity);
        }
      }
    } else {
      $('.items_left', $product).text('');
      $('.quantity', $product).removeAttr('max');
    } // Empty sold out text


    $('.sold-out-text', $product).text(''); // Show price, otherwise, show free price text

    if (variant.price > 0) {
      $('.current-price', $product).html('<span class="money">' + Shopify.formatMoney(variant.price, $('body').data('money-format')) + '</span>');

      if (unitPriceOutput !== undefined) {
        $unitPrice.html(unitPriceOutput);
      } else {
        $unitPrice.addClass('product-details__unit-price--hidden');
      }
    } else {
      $('.current-price', $product).html(window.PXUTheme.theme_settings.free_price_text);
      $unitPrice.addClass('product-details__unit-price--hidden');
    } // Remove the "product__price-container--sold-out" class and updated the add to cart text


    $('.product__price').show();
    $('.product__price-container', $product).removeClass('product__price-container--sold-out').show();
    $('.add_to_cart', $product).removeClass('disabled').removeAttr('disabled').find('span').text($('.add_to_cart', $product).data('label')); // Hide the back in stock notification form

    $notify_form.hide(); // Show the quantity field

    $('.purchase-details__quantity', $product).show(); // Remove disable from action buttons

    $('.atc-btn-container', $product).removeClass('disabled');
  } else {
    var message = variant ? window.PXUTheme.translation.product_sold_out : window.PXUTheme.translation.product_unavailable; // Hide the quantity field

    $('.purchase-details__quantity', $product).hide(); // Show the price and change the add to cart and sold out text

    $('.product__price-container', $product).addClass('product__price-container--sold-out').show();
    $('.add_to_cart', $product).find('span').text(message);
    $('.items_left', $product).text('');
    $('.quantity', $product).removeAttr('max');
    $('.sold-out-text', $product).text(' - ' + message); // Disable the add to cart button and Shopify payment button when a variant is sold out

    $('.atc-btn-container', $product).addClass('disabled'); // Hide the back in stock notification form

    $notify_form.hide();
    $notifyFormInputs.empty();

    if (variant && !variant.available) {
      var message = variant ? window.PXUTheme.translation.product_sold_out : window.PXUTheme.translation.product_unavailable; // Show the variant price, otherwise, show the free price text

      if (variant.price > 0) {
        $('.current-price', $product).html('<span class="money">' + Shopify.formatMoney(variant.price, $('body').data('money-format')) + '</span>');

        if (unitPriceOutput !== undefined) {
          $unitPrice.html(unitPriceOutput);
        } else {
          $unitPrice.addClass('product-details__unit-price--hidden');
        }
      } else {
        $('.current-price', $product).html(window.PXUTheme.theme_settings.free_price_text);
        $unitPrice.addClass('product-details__unit-price--hidden');
      } // When a variant is sold out but on sale


      if (variant.price < variant.compare_at_price) {
        $('.was-price', $product).html('<span class="money">' + Shopify.formatMoney(variant.compare_at_price, $('body').data('money-format')) + '</span>');
      } else {
        $('.was-price', $product).html('');
      } // Show the back in stock notification form


      $notify_form.fadeIn();
      $notifyFormInputs.empty();
      $notifyFormInputs.append(notifyFormHTML); // Show the price and change the add to cart and sold out text

      $('.product__price').show();
      $('.product__price-container--sold-out').show();
      $('.sold-out-text', $product).text(' - ' + message);
      $('.add_to_cart', $product).find('span').text(message);
    } else {
      // When a variant is specifically unavailable
      // Hide unit pricing when product is unavailable
      $unitPrice.addClass('product-details__unit-price--hidden'); // Change the add to cart and sold out text to "Unavailable"

      $('.add_to_cart', $product).find('span').text(window.PXUTheme.translation.product_unavailable);
      $('.sold-out-text', $product).text(window.PXUTheme.translation.product_unavailable); // Hide the product price

      $('.product__price').hide(); // Hide the back in stock notification form

      $notify_form.hide();
    }
  }

  $productForm.removeClass("init");
};

function htmlEncode(value) {
  if (value) {
    return $('<div/>').text(value).html();
  } else {
    return '';
  }
}

Shopify.updateOptionsInSelector = function (selectorIndex, parent) {
  switch (selectorIndex) {
    case 0:
      var key = 'root';
      var selector = $(parent + ' .single-option-selector:eq(0)');
      break;

    case 1:
      var key = $(parent + ' .single-option-selector:eq(0)').val();
      var selector = $(parent + ' .single-option-selector:eq(1)');
      break;

    case 2:
      var key = $(parent + ' .single-option-selector:eq(0)').val();
      key += ' / ' + $(parent + ' .single-option-selector:eq(1)').val();
      var selector = $(parent + ' .single-option-selector:eq(2)');
  }

  var availableOptions = Shopify.optionsMap[key];
  $(parent + ' .swatch[data-option-index="' + selectorIndex + '"] .swatch-element').each(function () {
    if ($.inArray($(this).attr('data-value'), availableOptions) !== -1) {
      $(this).removeClass('soldout').find(':radio').removeAttr('disabled', 'disabled').removeAttr('checked');
    } else {
      $(this).addClass('soldout').find(':radio').removeAttr('checked').attr('disabled', 'disabled');
    }
  });
  selector.trigger('change');
};
/* Linked Option Selectors */


Shopify.linkOptionSelectors = function (product, parent) {
  // Building our mapping object.
  Shopify.optionsMap = {};

  for (let i = 0; i < product.variants.length; i++) {
    var variant = product.variants[i];

    if (variant.available) {
      // Gathering values for the 1st drop-down.
      Shopify.optionsMap['root'] = Shopify.optionsMap['root'] || [];
      Shopify.optionsMap['root'].push(variant.option1);
      Shopify.optionsMap['root'] = Shopify.uniq(Shopify.optionsMap['root']); // Gathering values for the 2nd drop-down.

      if (product.options.length > 1) {
        var key = variant.option1;
        Shopify.optionsMap[key] = Shopify.optionsMap[key] || [];
        Shopify.optionsMap[key].push(variant.option2);
        Shopify.optionsMap[key] = Shopify.uniq(Shopify.optionsMap[key]);
      } // Gathering values for the 3rd drop-down.


      if (product.options.length === 3) {
        var key = variant.option1 + ' / ' + variant.option2;
        Shopify.optionsMap[key] = Shopify.optionsMap[key] || [];
        Shopify.optionsMap[key].push(variant.option3);
        Shopify.optionsMap[key] = Shopify.uniq(Shopify.optionsMap[key]);
      }
    }
  } // Update options right away.


  Shopify.updateOptionsInSelector(0, parent);
  if (product.options.length > 1) Shopify.updateOptionsInSelector(1, parent);
  if (product.options.length === 3) Shopify.updateOptionsInSelector(2, parent); // When there is an update in the first dropdown.

  $(parent + " .single-option-selector:eq(0)").change(function () {
    Shopify.updateOptionsInSelector(1, parent);
    if (product.options.length === 3) Shopify.updateOptionsInSelector(2, parent);
    return true;
  }); // When there is an update in the second dropdown.

  $(parent + " .single-option-selector:eq(1)").change(function () {
    if (product.options.length === 3) Shopify.updateOptionsInSelector(2, parent);
    return true;
  });
};

$(document).on('shopify:block:select', function (e) {
  var blockId = e.detail.blockId;
  var $parentSection = $('#shopify-section-' + e.detail.sectionId);

  if ($parentSection.hasClass('shopify-section--page-details-template')) {
    sliderBlock.select(blockId, $parentSection);
  }
});
$(document).on('shopify:block:load', function (e) {
  var blockId = e.detail.blockId;
  var $parentSection = $('#shopify-section-' + e.detail.sectionId);

  if ($parentSection.hasClass('shopify-section--page-details-template')) {
    sliderBlock.select(blockId, $parentSection);
  }
});
$(document).on('shopify:block:deselect', function (e) {
  var $parentSection = $('#shopify-section-' + e.detail.sectionId);

  if ($parentSection.hasClass('shopify-section--slideshow') || $parentSection.hasClass('shopify-section--testimonials')) {
    sliderBlock.deselect($parentSection);
  }
});
$(document).on('shopify:section:load', function (e) {
  //Load language/currency switchers
  window.utilities.enableDisclosure();

  if (window.PXUTheme.theme_settings.newsletter_popup) {
    newsletter_popup.init();
  } // Call methods based on section classes


  var $parentSection = $('#shopify-section-' + e.detail.sectionId);

  if ($parentSection.hasClass('shopify-section--recommended-products')) {
    window.product.loadProductRecommendations();
  }

  if ($parentSection.hasClass('shopify-section--map') || $parentSection.hasClass('shopify-section--page-contact-template') || $parentSection.hasClass('shopify-section--page-details-template') || $parentSection.hasClass('shopify-section--product-template')) {
    window.map.init();
    window.video.init();
  }

  if ($parentSection.hasClass('shopify-section--page-faq-template')) {
    window.faqAccordion.init();
  }

  if ($parentSection.hasClass('shopify-section--page-details-template')) {
    window.product.init();
  }

  if ($parentSection.hasClass('shopify-section--slideshow')) {
    window.slideshow.init($parentSection);
  }

  if ($parentSection.hasClass('shopify-section--featured-product')) {
    window.product.init();
    window.product.initializeQuantityBox();
    window.utils.initializeTabs();
  }

  if ($parentSection.hasClass('shopify-section--featured-collection')) {
    window.collection.init();
    window.product.init();
    window.product.initializeQuantityBox();
  }

  if ($parentSection.hasClass('shopify-section--video')) {
    window.video.init();
  }

  if ($parentSection.hasClass('shopify-section--product-template') || $parentSection.hasClass('shopify-section--quick-shop')) {
    window.collection.init();
    window.product.init();
    window.product.initializeQuantityBox();
    window.video.init();
  }

  if ($parentSection.hasClass('shopify-section--product-sidebar')) {
    window.product.loadProductRecommendations();
  }

  if ($parentSection.hasClass('shopify-section--collection-template')) {
    window.collection.init();
    window.product.init();
    window.product.initializeQuantityBox();
  }

  if ($parentSection.hasClass('shopify-section--search-template')) {
    window.collection.init();
  }

  if ($parentSection.hasClass('shopify-section--cart-template')) {
    window.product.initializeQuantityBox();
  }

  if ($parentSection.hasClass('shopify-section--header')) {
    window.header.init();
  }

  if (window.PXUTheme.theme_settings.enable_predictive_search) {
    predictiveSearch.init();
  }
});
$(document).on('shopify:section:unload', function (e) {
  //Load language/currency switchers
  window.utilities.unload();
  var $target = $(e.target);
  var $parentSection = $('#shopify-section-' + e.detail.sectionId);

  if ($parentSection.hasClass('shopify-section--slideshow')) {
    slideshow.unload($target);
  }

  if ($parentSection.hasClass('shopify-section--featured-product')) {
    window.product.unload($target);
    window.utils.unload($target);
  }

  if ($parentSection.hasClass('shopify-section--featured-collection')) {
    window.collection.unload($target);
  }

  if ($parentSection.hasClass('shopify-section--product-template') || $parentSection.hasClass('shopify-section--quick-shop')) {
    window.product.unload($target);
  }

  if ($parentSection.hasClass('shopify-section--page-faq-template')) {
    window.faqAccordion.unload($target);
  }

  if ($parentSection.hasClass('shopify-section--collection-template')) {
    window.collection.unload($target);
  }
});
$(document).on('shopify:section:select', function (e) {
  var $parentSection = $('#shopify-section-' + e.detail.sectionId);
});
$(document).on('shopify:section:deselect', function (e) {
  var $parentSection = $('#shopify-section-' + e.detail.sectionId);
});
})();

/******/ })()
;